(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))o(i);new MutationObserver(i=>{for(const n of i)if(n.type==="childList")for(const s of n.addedNodes)s.tagName==="LINK"&&s.rel==="modulepreload"&&o(s)}).observe(document,{childList:!0,subtree:!0});function r(i){const n={};return i.integrity&&(n.integrity=i.integrity),i.referrerPolicy&&(n.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?n.credentials="include":i.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function o(i){if(i.ep)return;i.ep=!0;const n=r(i);fetch(i.href,n)}})();var Xt=Object.defineProperty,Wt=(e,t,r)=>t in e?Xt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,I=(e,t,r)=>(Wt(e,typeof t!="symbol"?t+"":t,r),r),lt=1e-6,F=typeof Float32Array<"u"?Float32Array:Array;Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});function Bt(){var e=new F(9);return F!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}function Kt(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e}function K(){var e=new F(16);return F!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function X(e){var t=new F(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function Qt(e,t,r,o,i,n,s,a,c,l,u,h,d,p,v,f){var m=new F(16);return m[0]=e,m[1]=t,m[2]=r,m[3]=o,m[4]=i,m[5]=n,m[6]=s,m[7]=a,m[8]=c,m[9]=l,m[10]=u,m[11]=h,m[12]=d,m[13]=p,m[14]=v,m[15]=f,m}function xt(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function Jt(e,t){if(e===t){var r=t[1],o=t[2],i=t[3],n=t[6],s=t[7],a=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=r,e[6]=t[9],e[7]=t[13],e[8]=o,e[9]=n,e[11]=t[14],e[12]=i,e[13]=s,e[14]=a}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}function L(e,t){var r=t[0],o=t[1],i=t[2],n=t[3],s=t[4],a=t[5],c=t[6],l=t[7],u=t[8],h=t[9],d=t[10],p=t[11],v=t[12],f=t[13],m=t[14],b=t[15],S=r*a-o*s,_=r*c-i*s,g=r*l-n*s,M=o*c-i*a,x=o*l-n*a,A=i*l-n*c,B=u*f-h*v,N=u*m-d*v,Z=u*b-p*v,O=h*m-d*f,k=h*b-p*f,q=d*b-p*m,P=S*q-_*k+g*O+M*Z-x*N+A*B;return P?(P=1/P,e[0]=(a*q-c*k+l*O)*P,e[1]=(i*k-o*q-n*O)*P,e[2]=(f*A-m*x+b*M)*P,e[3]=(d*x-h*A-p*M)*P,e[4]=(c*Z-s*q-l*N)*P,e[5]=(r*q-i*Z+n*N)*P,e[6]=(m*g-v*A-b*_)*P,e[7]=(u*A-d*g+p*_)*P,e[8]=(s*k-a*Z+l*B)*P,e[9]=(o*Z-r*k-n*B)*P,e[10]=(v*x-f*g+b*S)*P,e[11]=(h*g-u*x-p*S)*P,e[12]=(a*N-s*O-c*B)*P,e[13]=(r*O-o*N+i*B)*P,e[14]=(f*_-v*M-m*S)*P,e[15]=(u*M-h*_+d*S)*P,e):null}function wt(e,t,r){var o=t[0],i=t[1],n=t[2],s=t[3],a=t[4],c=t[5],l=t[6],u=t[7],h=t[8],d=t[9],p=t[10],v=t[11],f=t[12],m=t[13],b=t[14],S=t[15],_=r[0],g=r[1],M=r[2],x=r[3];return e[0]=_*o+g*a+M*h+x*f,e[1]=_*i+g*c+M*d+x*m,e[2]=_*n+g*l+M*p+x*b,e[3]=_*s+g*u+M*v+x*S,_=r[4],g=r[5],M=r[6],x=r[7],e[4]=_*o+g*a+M*h+x*f,e[5]=_*i+g*c+M*d+x*m,e[6]=_*n+g*l+M*p+x*b,e[7]=_*s+g*u+M*v+x*S,_=r[8],g=r[9],M=r[10],x=r[11],e[8]=_*o+g*a+M*h+x*f,e[9]=_*i+g*c+M*d+x*m,e[10]=_*n+g*l+M*p+x*b,e[11]=_*s+g*u+M*v+x*S,_=r[12],g=r[13],M=r[14],x=r[15],e[12]=_*o+g*a+M*h+x*f,e[13]=_*i+g*c+M*d+x*m,e[14]=_*n+g*l+M*p+x*b,e[15]=_*s+g*u+M*v+x*S,e}function it(e,t,r){var o=r[0],i=r[1],n=r[2],s,a,c,l,u,h,d,p,v,f,m,b;return t===e?(e[12]=t[0]*o+t[4]*i+t[8]*n+t[12],e[13]=t[1]*o+t[5]*i+t[9]*n+t[13],e[14]=t[2]*o+t[6]*i+t[10]*n+t[14],e[15]=t[3]*o+t[7]*i+t[11]*n+t[15]):(s=t[0],a=t[1],c=t[2],l=t[3],u=t[4],h=t[5],d=t[6],p=t[7],v=t[8],f=t[9],m=t[10],b=t[11],e[0]=s,e[1]=a,e[2]=c,e[3]=l,e[4]=u,e[5]=h,e[6]=d,e[7]=p,e[8]=v,e[9]=f,e[10]=m,e[11]=b,e[12]=s*o+u*i+v*n+t[12],e[13]=a*o+h*i+f*n+t[13],e[14]=c*o+d*i+m*n+t[14],e[15]=l*o+p*i+b*n+t[15]),e}function te(e,t,r){var o=r[0],i=r[1],n=r[2];return e[0]=t[0]*o,e[1]=t[1]*o,e[2]=t[2]*o,e[3]=t[3]*o,e[4]=t[4]*i,e[5]=t[5]*i,e[6]=t[6]*i,e[7]=t[7]*i,e[8]=t[8]*n,e[9]=t[9]*n,e[10]=t[10]*n,e[11]=t[11]*n,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function Dt(e,t,r){var o=Math.sin(r),i=Math.cos(r),n=t[4],s=t[5],a=t[6],c=t[7],l=t[8],u=t[9],h=t[10],d=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=n*i+l*o,e[5]=s*i+u*o,e[6]=a*i+h*o,e[7]=c*i+d*o,e[8]=l*i-n*o,e[9]=u*i-s*o,e[10]=h*i-a*o,e[11]=d*i-c*o,e}function Et(e,t,r){var o=Math.sin(r),i=Math.cos(r),n=t[0],s=t[1],a=t[2],c=t[3],l=t[8],u=t[9],h=t[10],d=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=n*i-l*o,e[1]=s*i-u*o,e[2]=a*i-h*o,e[3]=c*i-d*o,e[8]=n*o+l*i,e[9]=s*o+u*i,e[10]=a*o+h*i,e[11]=c*o+d*i,e}function Ut(e,t,r){var o=Math.sin(r),i=Math.cos(r),n=t[0],s=t[1],a=t[2],c=t[3],l=t[4],u=t[5],h=t[6],d=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=n*i+l*o,e[1]=s*i+u*o,e[2]=a*i+h*o,e[3]=c*i+d*o,e[4]=l*i-n*o,e[5]=u*i-s*o,e[6]=h*i-a*o,e[7]=d*i-c*o,e}function ee(e,t,r){var o=t[0],i=t[1],n=t[2],s=t[3],a=o+o,c=i+i,l=n+n,u=o*a,h=o*c,d=o*l,p=i*c,v=i*l,f=n*l,m=s*a,b=s*c,S=s*l;return e[0]=1-(p+f),e[1]=h+S,e[2]=d-b,e[3]=0,e[4]=h-S,e[5]=1-(u+f),e[6]=v+m,e[7]=0,e[8]=d+b,e[9]=v-m,e[10]=1-(u+p),e[11]=0,e[12]=r[0],e[13]=r[1],e[14]=r[2],e[15]=1,e}function re(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}function oe(e,t){var r=t[0],o=t[1],i=t[2],n=t[4],s=t[5],a=t[6],c=t[8],l=t[9],u=t[10];return e[0]=Math.hypot(r,o,i),e[1]=Math.hypot(n,s,a),e[2]=Math.hypot(c,l,u),e}function ie(e,t,r,o){var i=t[0],n=t[1],s=t[2],a=t[3],c=i+i,l=n+n,u=s+s,h=i*c,d=i*l,p=i*u,v=n*l,f=n*u,m=s*u,b=a*c,S=a*l,_=a*u,g=o[0],M=o[1],x=o[2];return e[0]=(1-(v+m))*g,e[1]=(d+_)*g,e[2]=(p-S)*g,e[3]=0,e[4]=(d-_)*M,e[5]=(1-(h+m))*M,e[6]=(f+b)*M,e[7]=0,e[8]=(p+S)*x,e[9]=(f-b)*x,e[10]=(1-(h+v))*x,e[11]=0,e[12]=r[0],e[13]=r[1],e[14]=r[2],e[15]=1,e}function ne(e,t){var r=t[0],o=t[1],i=t[2],n=t[3],s=r+r,a=o+o,c=i+i,l=r*s,u=o*s,h=o*a,d=i*s,p=i*a,v=i*c,f=n*s,m=n*a,b=n*c;return e[0]=1-h-v,e[1]=u+b,e[2]=d-m,e[3]=0,e[4]=u-b,e[5]=1-l-v,e[6]=p+f,e[7]=0,e[8]=d+m,e[9]=p-f,e[10]=1-l-h,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function se(e,t,r,o,i){var n=1/Math.tan(t/2),s;return e[0]=n/r,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=n,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,i!=null&&i!==1/0?(s=1/(o-i),e[10]=(i+o)*s,e[14]=2*i*o*s):(e[10]=-1,e[14]=-2*o),e}var ae=se;function Rt(e,t,r,o){var i,n,s,a,c,l,u,h,d,p,v=t[0],f=t[1],m=t[2],b=o[0],S=o[1],_=o[2],g=r[0],M=r[1],x=r[2];return Math.abs(v-g)<lt&&Math.abs(f-M)<lt&&Math.abs(m-x)<lt?xt(e):(u=v-g,h=f-M,d=m-x,p=1/Math.hypot(u,h,d),u*=p,h*=p,d*=p,i=S*d-_*h,n=_*u-b*d,s=b*h-S*u,p=Math.hypot(i,n,s),p?(p=1/p,i*=p,n*=p,s*=p):(i=0,n=0,s=0),a=h*s-d*n,c=d*i-u*s,l=u*n-h*i,p=Math.hypot(a,c,l),p?(p=1/p,a*=p,c*=p,l*=p):(a=0,c=0,l=0),e[0]=i,e[1]=a,e[2]=u,e[3]=0,e[4]=n,e[5]=c,e[6]=h,e[7]=0,e[8]=s,e[9]=l,e[10]=d,e[11]=0,e[12]=-(i*v+n*f+s*m),e[13]=-(a*v+c*f+l*m),e[14]=-(u*v+h*f+d*m),e[15]=1,e)}function et(){var e=new F(3);return F!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function ce(e){var t=e[0],r=e[1],o=e[2];return Math.hypot(t,r,o)}function ct(e,t,r){var o=new F(3);return o[0]=e,o[1]=t,o[2]=r,o}function ue(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e}function le(e,t){var r=t[0],o=t[1],i=t[2],n=r*r+o*o+i*i;return n>0&&(n=1/Math.sqrt(n)),e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function St(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function at(e,t,r){var o=t[0],i=t[1],n=t[2],s=r[0],a=r[1],c=r[2];return e[0]=i*c-n*a,e[1]=n*s-o*c,e[2]=o*a-i*s,e}var he=ce;(function(){var e=et();return function(t,r,o,i,n,s){var a,c;for(r||(r=3),o||(o=0),i?c=Math.min(i*r+o,t.length):c=t.length,a=o;a<c;a+=r)e[0]=t[a],e[1]=t[a+1],e[2]=t[a+2],n(e,e,s),t[a]=e[0],t[a+1]=e[1],t[a+2]=e[2];return t}})();function Nt(){var e=new F(4);return F!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0,e[3]=0),e}function de(e){var t=new F(4);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t}function G(e,t,r,o){var i=new F(4);return i[0]=e,i[1]=t,i[2]=r,i[3]=o,i}function Zt(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e[3]=t[3]+r[3],e}function Ot(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e[3]=t[3]-r[3],e}function fe(e,t,r){return e[0]=t[0]*r[0],e[1]=t[1]*r[1],e[2]=t[2]*r[2],e[3]=t[3]*r[3],e}function pe(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e}function me(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=-t[3],e}function tt(e,t){var r=t[0],o=t[1],i=t[2],n=t[3],s=r*r+o*o+i*i+n*n;return s>0&&(s=1/Math.sqrt(s)),e[0]=r*s,e[1]=o*s,e[2]=i*s,e[3]=n*s,e}function R(e,t,r){var o=t[0],i=t[1],n=t[2],s=t[3];return e[0]=r[0]*o+r[4]*i+r[8]*n+r[12]*s,e[1]=r[1]*o+r[5]*i+r[9]*n+r[13]*s,e[2]=r[2]*o+r[6]*i+r[10]*n+r[14]*s,e[3]=r[3]*o+r[7]*i+r[11]*n+r[15]*s,e}(function(){var e=Nt();return function(t,r,o,i,n,s){var a,c;for(r||(r=4),o||(o=0),i?c=Math.min(i*r+o,t.length):c=t.length,a=o;a<c;a+=r)e[0]=t[a],e[1]=t[a+1],e[2]=t[a+2],e[3]=t[a+3],n(e,e,s),t[a]=e[0],t[a+1]=e[1],t[a+2]=e[2],t[a+3]=e[3];return t}})();function dt(){var e=new F(4);return F!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function ve(e,t,r){r=r*.5;var o=Math.sin(r);return e[0]=o*t[0],e[1]=o*t[1],e[2]=o*t[2],e[3]=Math.cos(r),e}function ge(e,t,r){var o=t[0],i=t[1],n=t[2],s=t[3],a=r[0],c=r[1],l=r[2],u=r[3];return e[0]=o*u+s*a+i*l-n*c,e[1]=i*u+s*c+n*a-o*l,e[2]=n*u+s*l+o*c-i*a,e[3]=s*u-o*a-i*c-n*l,e}function _e(e,t,r){r*=.5;var o=t[0],i=t[1],n=t[2],s=t[3],a=Math.sin(r),c=Math.cos(r);return e[0]=o*c+s*a,e[1]=i*c+n*a,e[2]=n*c-i*a,e[3]=s*c-o*a,e}function ye(e,t,r){r*=.5;var o=t[0],i=t[1],n=t[2],s=t[3],a=Math.sin(r),c=Math.cos(r);return e[0]=o*c-n*a,e[1]=i*c+s*a,e[2]=n*c+o*a,e[3]=s*c-i*a,e}function xe(e,t,r){r*=.5;var o=t[0],i=t[1],n=t[2],s=t[3],a=Math.sin(r),c=Math.cos(r);return e[0]=o*c+i*a,e[1]=i*c-o*a,e[2]=n*c+s*a,e[3]=s*c-n*a,e}function pt(e,t,r,o){var i=t[0],n=t[1],s=t[2],a=t[3],c=r[0],l=r[1],u=r[2],h=r[3],d,p,v,f,m;return p=i*c+n*l+s*u+a*h,p<0&&(p=-p,c=-c,l=-l,u=-u,h=-h),1-p>lt?(d=Math.acos(p),v=Math.sin(d),f=Math.sin((1-o)*d)/v,m=Math.sin(o*d)/v):(f=1-o,m=o),e[0]=f*i+m*c,e[1]=f*n+m*l,e[2]=f*s+m*u,e[3]=f*a+m*h,e}function Q(e,t){var r=t[0],o=t[1],i=t[2],n=t[3],s=r*r+o*o+i*i+n*n,a=s?1/s:0;return e[0]=-r*a,e[1]=-o*a,e[2]=-i*a,e[3]=n*a,e}function kt(e,t){var r=t[0]+t[4]+t[8],o;if(r>0)o=Math.sqrt(r+1),e[3]=.5*o,o=.5/o,e[0]=(t[5]-t[7])*o,e[1]=(t[6]-t[2])*o,e[2]=(t[1]-t[3])*o;else{var i=0;t[4]>t[0]&&(i=1),t[8]>t[i*3+i]&&(i=2);var n=(i+1)%3,s=(i+2)%3;o=Math.sqrt(t[i*3+i]-t[n*3+n]-t[s*3+s]+1),e[i]=.5*o,o=.5/o,e[3]=(t[n*3+s]-t[s*3+n])*o,e[n]=(t[n*3+i]+t[i*3+n])*o,e[s]=(t[s*3+i]+t[i*3+s])*o}return e}var ut=de,we=G,qt=tt;(function(){var e=et(),t=ct(1,0,0),r=ct(0,1,0);return function(o,i,n){var s=St(i,n);return s<-.999999?(at(e,t,i),he(e)<1e-6&&at(e,r,i),le(e,e),ve(o,e,Math.PI),o):s>.999999?(o[0]=0,o[1]=0,o[2]=0,o[3]=1,o):(at(e,i,n),o[0]=e[0],o[1]=e[1],o[2]=e[2],o[3]=1+s,qt(o,o))}})();(function(){var e=dt(),t=dt();return function(r,o,i,n,s,a){return pt(e,o,s,a),pt(t,i,n,a),pt(r,e,t,2*a*(1-a)),r}})();(function(){var e=Bt();return function(t,r,o,i){return e[0]=o[0],e[3]=o[1],e[6]=o[2],e[1]=i[0],e[4]=i[1],e[7]=i[2],e[2]=-r[0],e[5]=-r[1],e[8]=-r[2],qt(t,kt(t,e))}})();const ht=class H{constructor(){I(this,"_coord"),I(this,"scale",t=>{const r=new H;return pe(r._coord,this._coord,t),r}),I(this,"dot",t=>St(this.vec3(),t.vec3())),I(this,"add",t=>{const r=new H;return Zt(r._coord,this._coord,t._coord),r}),I(this,"multiply",t=>{const r=new H;return fe(r._coord,this._coord,t._coord),r}),this._coord=G(0,0,0,0)}static get bufferSize(){return 4*4}static fromValues(t,r,o){const i=new H;return i._coord=G(t,r,o,0),i}static fromVec4(t){const r=new H,o=t[3]!==0?t[3]:1;return r._coord=G(t[0]/o,t[1]/o,t[2]/o,0),r}static fromVec3(t){const r=new H;return r._coord=G(t[0],t[1],t[2],0),r}static fromPoints(t,r){const o=new H;return Ot(o._coord,t.vec4(),r.vec4()),o}static fromPoint(t){const r=new H;return r._coord=[...t.triplet,0],r}toString(){return`Vector(${this.x}, ${this.y}, ${this.z})`}map(t){const r=new H;return t.isFrame()?R(r._coord,this._coord,t.inverseMatrix):R(r._coord,this._coord,t.directMatrix),r}unMap(t){const r=new H;return t.isFrame()?R(r._coord,this._coord,t.directMatrix):R(r._coord,this._coord,t.inverseMatrix),r}relative(t){return this.map(t)}absolute(t){return this.unMap(t)}isUnitVector(){return!1}get x(){return this._coord[0]}get y(){return this._coord[1]}get z(){return this._coord[2]}get triplet(){return[this.x,this.y,this.z]}get coordinates(){return[...this._coord.values()]}buffer(){return new Float32Array(this.coordinates)}get length(){const t=this._coord[0],r=this._coord[1],o=this._coord[2];return Math.sqrt(t*t+r*r+o*o)}get lengthSquare(){const t=this._coord[0],r=this._coord[1],o=this._coord[2];return t*t+r*r+o*o}vec3(){return ct(this.x,this.y,this.z)}vec4(){return G(this.x,this.y,this.z,0)}};I(ht,"crossProduct",(e,t)=>{const r=et();return at(r,e.vec3(),t.vec3()),ht.fromVec3(r)}),I(ht,"dot",(e,t)=>St(e.vec3(),t.vec3()));let C=ht;class y{constructor(){I(this,"_coord"),this._coord=G(0,0,0,1)}static get bufferSize(){return 4*4}static origin(){return new y}static fromValues(t,r,o,i=1){const n=new y;return n._coord=G(t/i,r/i,o/i,1),n}static fromVector(t){const r=new y;return r._coord=G(t.x,t.y,t.z,1),r}static fromVec4(t){const r=new y,o=t[3]!==0?t[3]:1;return r._coord=G(t[0]/o,t[1]/o,t[2]/o,1),r}static fromVec3(t){const r=new y;return r._coord=G(t[0],t[1],t[2],1),r}toString(){return`Point(${this.x}, ${this.y}, ${this.z})`}map(t){const r=new y;return t.isFrame()?R(r._coord,this._coord,t.inverseMatrix):R(r._coord,this._coord,t.directMatrix),r}unMap(t){const r=new y;return t.isFrame()?R(r._coord,this._coord,t.directMatrix):R(r._coord,this._coord,t.inverseMatrix),r}relative(t){return this.map(t)}absolute(t){return this.unMap(t)}static relative(t,r){return t.map(r)}static absolute(t,r){return t.unMap(r)}subtract(t){const r=Nt();return Ot(r,this._coord,t._coord),C.fromVec4(r)}scale(t){const r=et();return ue(r,this.vec3(),t),y.fromVec3(r)}add(t){const r=new y;return Zt(r._coord,this._coord,t.vec4()),r}isPoint(){return!0}get x(){return this._coord[0]}get y(){return this._coord[1]}get z(){return this._coord[2]}get coordinates(){return[...this._coord.values()]}get triplet(){return[this.x,this.y,this.z]}buffer(){return new Float32Array(this.coordinates)}vec3(){return ct(this.x,this.y,this.z)}vec4(){return G(this.x,this.y,this.z,1)}}const bt=class ${constructor(){I(this,"_coord"),this._coord=G(1,1,1,0)}static get bufferSize(){return 4*4}static fromVector(t){const r=new $;return r._coord=G(t.x,t.y,t.z,0),tt(r._coord,r._coord),r}static fromPoints(t,r){const o=new $;return o._coord=G(t.x-r.x,t.y-r.y,t.z-r.z,0),tt(o._coord,o._coord),o}fromPoint(t){return $.fromValues(...t.triplet)}static fromValues(t,r,o){const i=G(t,r,o,0);return tt(i,i),$.fromVec4(i)}static fromVec4(t){const r=new $,o=t[3]!==0?t[3]:1;return r._coord=G(t[0]/o,t[1]/o,t[2]/o,0),tt(r._coord,r._coord),r}static fromVec3(t){const r=new $;return r._coord=G(t[0],t[1],t[2],0),tt(r._coord,r._coord),r}toString(){return`UnitVector(${this.x}, ${this.y}, ${this.z})`}map(t){const r=new $;return t.isFrame()?R(r._coord,this._coord,t.inverseMatrix):R(r._coord,this._coord,t.directMatrix),tt(r._coord,r._coord),r}unMap(t){const r=new $;return t.isFrame()?R(r._coord,this._coord,t.directMatrix):R(r._coord,this._coord,t.inverseMatrix),tt(r._coord,r._coord),r}relative(t){return this.map(t)}absolute(t){return this.unMap(t)}invert(){const t=new $;return me(t._coord,this._coord),t}scale(t){return C.fromValues(this.x*t,this.y*t,this.z*t)}isUnitVector(){return!0}get x(){return this._coord[0]}get y(){return this._coord[1]}get z(){return this._coord[2]}get length(){return 1}get coordinates(){return[...this._coord.values()]}get triplet(){return[this.x,this.y,this.z]}buffer(){return new Float32Array(this.coordinates)}vec3(){return ct(this.x,this.y,this.z)}};I(bt,"crossProduct",(e,t)=>{const r=et();return at(r,e.vec3(),t.vec3()),bt.fromVec3(r)});let V=bt;const Pt=e=>e.isUnitVector();class w{constructor(){I(this,"_direct"),I(this,"_inverse"),I(this,"_isIdentity",!0),this._direct=K(),this._inverse=K(),L(this._inverse,this._direct)}static get bufferSize(){return 16*4}static world(){return new w}static identity(){return new w}static fromRotation(t){const r=new w;return ne(r._direct,t.quat),L(r._inverse,r._direct),r._isIdentity=!1,r}static fromMat4(t){const r=new w,o=K();return L(o,t),r._direct=X(t),r._inverse=X(o),r._isIdentity=!1,r}static lookAt(t,r,o){const i=new w;return Rt(i._direct,t.vec3(),r.vec3(),o.vec3()),L(i._inverse,i._direct),i._isIdentity=!1,i}static perspective(t,r,o,i){const n=new w;return ae(n._direct,t,r,o,i),L(n._inverse,n._direct),n._isIdentity=!1,n}static invert(t){const r=new w;return r._direct=X(t._inverse),r._inverse=X(t._direct),r._isIdentity=!1,r}static translation(t,r,o){const i=new w;return it(i._direct,i._direct,[t,r,o]),L(i._inverse,i._direct),i._isIdentity=!1,i}static move(t){const r=new w;return it(r._direct,r._direct,t.vec3()),L(r._inverse,r._direct),r._isIdentity=!1,r}static rotationX(t){const r=new w;return Dt(r._direct,r._direct,t),L(r._inverse,r._direct),r._isIdentity=!1,r}static rotationY(t){const r=new w;return Et(r._direct,r._direct,t),L(r._inverse,r._direct),r._isIdentity=!1,r}static rotationZ(t){const r=new w;return Ut(r._direct,r._direct,t),L(r._inverse,r._direct),r._isIdentity=!1,r}static scale(t,r,o){const i=new w;return te(i._direct,i._direct,[t,r,o]),L(i._inverse,i._direct),i._isIdentity=!1,i}static rotoTranslation(t,r){const o=new w;return ee(o._direct,t.quat,r.vec3()),L(o._inverse,o._direct),o._isIdentity=!1,o}static fromRotationTranslationScale(t,r,o){const i=new w;return ie(i._direct,t.quat,r.vec3(),o.vec3()),L(i._inverse,i._direct),i._isIdentity=!1,i}isFrame(){return!1}get values(){return this._direct.values()}get inverseValues(){return this._inverse.values()}buffer(){return new Float32Array(this._direct.values())}inverseBuffer(){return new Float32Array(this._inverse.values())}apply(t){return t.map(this)}compose(t){const r=new w,{_direct:o,_inverse:i}=this,{_direct:n,_inverse:s}=t;return wt(r._direct,n,o),wt(r._inverse,i,s),r._isIdentity=!1,r}transpose(){const t=new w;return Jt(t._direct,this._direct),L(t._inverse,t._direct),t._isIdentity=!1,t}translation(t,r,o){const i=w.translation(t,r,o);return this.compose(i)}rotationX(t){const r=w.rotationX(t);return this.compose(r)}rotationY(t){const r=w.rotationY(t);return this.compose(r)}rotationZ(t){const r=w.rotationZ(t);return this.compose(r)}scale(t,r,o){const i=w.scale(t,r,o);return this.compose(i)}invert(){const t=new w;return t._direct=X(this._inverse),t._inverse=X(this._direct),t._isIdentity=this._isIdentity,t}get directMatrix(){return this._direct}get inverseMatrix(){return this._inverse}get isIdentity(){return this._isIdentity}get scaleVector(){const t=et();return oe(t,this._direct),C.fromValues(t[0],t[1],t[2])}get positionVector(){const t=et();return re(t,this._direct),C.fromValues(t[0],t[1],t[2])}}const Mt=class Y{constructor(){I(this,"_direct"),I(this,"_inverse"),this._direct=K(),this._inverse=K(),xt(this._direct),xt(this._inverse)}static bufferSize(){return 16*4}static world(){return new Y}static translation(t){const r=new Y,o=K();return it(o,o,t.vec3()),r._inverse=o,L(r._direct,r._inverse),r}static rotationX(t,r){const o=new Y,i=K();return it(i,i,t.vec3()),Dt(i,i,r),o._direct=i,L(o._inverse,o._direct),o}static rotationY(t,r){const o=new Y,i=K();return it(i,i,t.vec3()),Et(i,i,r),o._direct=i,L(o._inverse,o._direct),o}static rotationZ(t,r){const o=new Y,i=K();return it(i,i,t.vec3()),Ut(i,i,r),o._direct=i,L(o._inverse,o._direct),o}static lookAt(t,r,o){const i=new Y;return Rt(i._inverse,t.vec3(),r.vec3(),o.vec3()),L(i._direct,i._inverse),i}isFrame(){return!0}toString(){return`Frame(${this.origin}, ${this.i}, ${this.j}, ${this.k})`}map(t){return this.compose(t)}unMap(t){return this.invert().compose(t)}compose(t){const r=new Y,{_direct:o}=this,{_direct:i}=t;return wt(r._direct,i,o),L(r._inverse,r._direct),r}toTransform(){return w.fromMat4(this._inverse)}invert(){const t=new Y;return t._direct=X(this._inverse),t._inverse=X(this._direct),t}get directMatrix(){return X(this._direct)}get inverseMatrix(){return X(this._inverse)}get i(){return V.fromValues(this._direct[0],this._direct[1],this._direct[2])}get j(){return V.fromValues(this._direct[4],this._direct[5],this._direct[6])}get k(){return V.fromValues(this._direct[8],this._direct[9],this._direct[10])}get o(){return y.fromValues(this._direct[12],this._direct[13],this._direct[14],this._direct[15])}get origin(){return y.fromValues(this._inverse[12],this._inverse[13],this._inverse[14],this._inverse[15])}relative(t){if(t&&be(t)){const r=this.origin.relative(t),o=this.k.relative(t),i=this.i.relative(t);return Y.from2Vectors(r,o,i)}return t.relative(this)}};I(Mt,"from2Vectors",(e,t,r)=>{const o=new Mt,i=Pt(t)?t:V.fromVector(t),n=V.crossProduct(i,Pt(r)?r:V.fromVector(r)),s=[...V.crossProduct(n,i).coordinates,...n.coordinates,...i.coordinates,...e.coordinates];return o._direct=Qt(...s),L(o._inverse,o._direct),o});let Vt=Mt;const be=e=>e&&e.isFrame!==void 0?e.isFrame():!1;let j=class z{constructor(){I(this,"_direct"),I(this,"_inverse"),this._direct=dt(),this._inverse=dt()}static identity(){return new z}static fromValues(t,r,o,i){const n=new z;return n._direct=we(t,r,o,i),Q(n._inverse,n._direct),n}static fromAngles(t,r,o){return z.rotationX(t).rotateY(r).rotateZ(o)}static fromQuat(t){const r=new z;return r._direct=ut(t),Q(r._inverse,r._direct),r}static fromArray(t){const r=new z;return r._direct=ut(t),Q(r._inverse,r._direct),r}static fromTransform(t){const r=Bt();Kt(r,t.directMatrix);const o=new z;return o._direct=kt(o._direct,r),Q(o._inverse,o._direct),o}static rotationX(t){const r=new z;return _e(r._direct,r._direct,t),Q(r._inverse,r._direct),r}static rotationY(t){const r=new z;return ye(r._direct,r._direct,t),Q(r._inverse,r._direct),r}static rotationZ(t){const r=new z;return xe(r._direct,r._direct,t),Q(r._inverse,r._direct),r}rotateX(t){const r=new z;return r._direct=this._direct,r._inverse=this._inverse,r.compose(z.rotationX(t)),r}rotateY(t){const r=new z;return r._direct=this._direct,r._inverse=this._inverse,r.compose(z.rotationY(t)),r}rotateZ(t){const r=new z;return r._direct=this._direct,r._inverse=this._inverse,r.compose(z.rotationZ(t)),r}inverse(){const t=new z;return t._direct=ut(this._inverse),t._inverse=ut(this._direct),t}compose(t){const r=new z;return ge(r._direct,this._direct,t._direct),Q(r._inverse,r._direct),r}get quat(){return this._direct}};const U=e=>e/180*Math.PI;var Me=Object.defineProperty,Ve=(e,t,r)=>t in e?Me(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,T=(e,t,r)=>(Ve(e,typeof t!="symbol"?t+"":t,r),r);const Ct=()=>{let e=0,t=performance.now(),r=0;const o=[];return{getFPS:()=>o.reduce((i,n)=>i+n,0)/o.length,measureFPS:()=>(e=performance.now()-t,e<=1?o[r]:(r=(r+1)%10,o[r]=1e3/e,t=performance.now(),e)),getLastTimeSpan:()=>e}},Se=async({context:e,device:t,format:r},o)=>{e.configure({device:t,format:r,alphaMode:"opaque"});const i=t.createShaderModule({code:o});return(await i.getCompilationInfo()).messages.forEach(n=>{let s=n.message;n.lineNum&&(s=`Line ${n.lineNum}:${n.linePos} - "${o.substr(n.offset,n.length+40)}"
`+n.message),console.error("WGSL error: ",s)}),i},Te=(e,t,r=GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST)=>{const o=e.createBuffer({size:t.byteLength,usage:r,mappedAtCreation:!0});return new Float32Array(o.getMappedRange()).set(t),o.unmap(),o},Lt=e=>{const{device:t,canvas:r}=e,o=t.createTexture({size:{width:r.width,height:r.height,depthOrArrayLayers:1},sampleCount:1,format:e.format,usage:GPUTextureUsage.RENDER_ATTACHMENT}),i=t.createTexture({label:"DepthTexture",sampleCount:1,size:[r.width,r.height,1],format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT}),n=Oe(window.getComputedStyle(r).backgroundColor);return{colorAttachments:[{view:o.createView(),clearValue:n,loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:i.createView(),depthClearValue:1,depthStoreOp:"store",depthLoadOp:"clear"}}},Pe=async e=>{const t=await navigator.gpu.requestAdapter({powerPreference:"high-performance"});if(!t)throw new Error("WebGPU:adapter is NOT available!");const r=await t.requestDevice();if(!r)throw new Error("WebGPU:device is NOT available!");const o=e.getContext("webgpu");if(!o)throw new Error("WebGPU:context from instantiated Canvas not available!");const i=navigator.gpu.getPreferredCanvasFormat();o.configure({device:r,format:i,usage:GPUTextureUsage.RENDER_ATTACHMENT,alphaMode:"opaque"});const n=await t.requestAdapterInfo();return console.info("WebGPU: adapter:",n),console.info("WebGPU: fallback adapter:",t.isFallbackAdapter),console.info("WegGPU: maxBindGroups:",r.limits.maxBindGroups),{context:o,device:r,canvas:e,format:i}},Ce=e=>typeof e=="string",Le=(e,[t,r],o)=>({view:o&&o.view?o.view(e.view):w.lookAt(y.fromValues(-5,-5,-5),y.fromValues(0,0,0),V.fromValues(0,0,1)),projection:o&&o.projection?o.projection(e.projection):w.perspective(Math.PI/5,t/r,.1,100)}),Ae=e=>e!==null,ze=e=>{const t=3*w.bufferSize+8+4*(2*C.bufferSize)+4*(C.bufferSize+y.bufferSize),r=4,o=r*(2*C.bufferSize)+r*(C.bufferSize+y.bufferSize)+4*4,i=e.device.createBuffer({label:"TransBuffer",size:t+t%16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),n=e.device.createBuffer({label:"LightBuffer",size:o+o%16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),s=[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}],a=e.device.createBindGroupLayout({label:"transformations",entries:s}),c=[{binding:0,resource:{buffer:i}},{binding:1,resource:{buffer:n}}],l=e.device.createBindGroup({label:"SceneData",layout:a,entries:c});return[a,l,[i,n]]},Ge=e=>{const t=2*w.bufferSize,r=e.device.createBuffer({label:"TransBuffer",size:t+t%16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),o=[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}],i=e.device.createBindGroupLayout({label:"modelTransf",entries:o}),n=[{binding:0,resource:{buffer:r}}],s=e.device.createBindGroup({label:"SceneData",layout:i,entries:n});return[i,s,[r]]},Ie=e=>{const t=e.device.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),r=e.device.createBuffer({size:4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),o=[{binding:0,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}],i=e.device.createBindGroupLayout({label:"color",entries:o}),n=[{binding:0,resource:{buffer:t}},{binding:1,resource:{buffer:r}}],s=e.device.createBindGroup({label:"color",layout:i,entries:n});return[i,s,[t,r]]},Fe=(e,t)=>{const{device:r}=e,o={addressModeU:"repeat",addressModeV:"repeat",magFilter:"linear",minFilter:"nearest",mipmapFilter:"linear",maxAnisotropy:1},i=r.createSampler(o),n=t.views.filter(Ae),s=[...n.map((u,h)=>({binding:h,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"float"}})),{binding:4,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}}],a=e.device.createBindGroupLayout({label:"texture",entries:s}),c=[...n.map((u,h)=>({binding:h,resource:u})),{binding:4,resource:i}],l=e.device.createBindGroup({label:"texture",layout:a,entries:c});return[a,l]},Be=(e,t)=>{const{device:r}=e,[o,i,n]=ze(e),[s,a,c]=Ie(e),[l,u,h]=Ge(e),[d,p]=t?Fe(e,t):[void 0,void 0],v=d?[o,s,l,d]:[o,s,l],f={sceneGroup:i,colorGroup:a,modelGroup:u,texturesGroup:p},m={sceneBuffers:n,colorBuffers:c,modelBuffers:h};return[r.createPipelineLayout({bindGroupLayouts:v}),f,m]},At=(e,t,r)=>{const{device:o,format:i}=e,n=r.map(s=>{const[a,c,l]=Be(e,s.material),u={label:s.label,layout:a,multisample:{count:1},vertex:{module:t,entryPoint:s.vertexShader,buffers:[s.bufferLayout]},fragment:{module:t,entryPoint:s.fragmentShader,targets:[{format:i,blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"}}}]},primitive:{topology:s.primitives,cullMode:s.cullMode},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"}},h=o.createRenderPipeline(u),d={...u,label:`${s.label}-alt`,primitive:{topology:s.primitives==="line-list"?s.primitives:"line-strip",cullMode:"none"}},p=o.createRenderPipeline(d);return[s.id,{id:s.id,type:s.label,pipeline:h,altPipeline:p,geoRenderable:s,uniformBuffers:l,bindGroups:c}]});return new Map(n)},De=(e,t)=>{let r="none",o=[0,0],i=[0,0],n=[0,0];e.addEventListener("contextmenu",s=>{s.preventDefault()}),e.addEventListener("wheel",s=>{s.ctrlKey?t.tilt(s.deltaY):t.zoom(s.deltaY)}),e.addEventListener("pointerdown",s=>{e.setPointerCapture(s.pointerId),o=[s.offsetX,s.offsetY],i=[0,0],n=o,r=`${s.ctrlKey?"ctrl-":""}mouse-${s.button}`,t.move(r,{origin:o,direction:i},n)}),e.addEventListener("pointermove",s=>{if(r==="none")return;const a=[s.offsetX,s.offsetY];i=[a[0]-n[0],a[1]-n[1]],n=a,t.move(r,{origin:o,direction:i},n)}),e.addEventListener("pointerup",s=>{e.releasePointerCapture(s.pointerId);const a=[s.offsetX,s.offsetY];i=[a[0]-o[0],a[1]-o[1]],i[0]<=.9&&i[1]<=.9&&t.click("none",a),t.move("none",{origin:o,direction:i},a),r="none"})},Ee=`const MAX_DIR_LIGHTS: u32 = 4;
const MAX_POINT_LIGHTS: u32 = 4;

struct DirectionalLight {
  dir: vec4<f32>,
  col: vec4<f32>,
};

struct PointLight {
  pos: vec4<f32>,  // Position of the light
  col: vec4<f32>,  // Color of the light
};

struct SceneData {
  view: mat4x4<f32>,
  invertView: mat4x4<f32>,
  projection: mat4x4<f32>,
};

struct ModelData {
  model: mat4x4<f32>,
  modelInverseTranspose: mat4x4<f32>,
};

struct SceneLights {
  dirLights: array<DirectionalLight, MAX_DIR_LIGHTS>,
  pointLights: array<PointLight, MAX_POINT_LIGHTS>,
  ambient: vec4<f32>,
};

struct ObjectData {
  model: mat4x4<f32>,
};

struct TextFragment {
  @builtin(position) position: vec4<f32>,
  @location(0) texCoord: vec2<f32>,
  @location(1) normal: vec3<f32>,
  @location(2) pos: vec3<f32>,
  @location(3) eye: vec3<f32>,
  @location(4) viewZ: f32,
};

struct ColorFragment {
  @builtin(position) position: vec4<f32>,
  @location(0) normal: vec3<f32>,
  @location(1) pos: vec3<f32>,
  @location(2) eye: vec3<f32>,
  @location(3) viewZ: f32,
};

struct ColorLineFragment {
  @builtin(position) position: vec4<f32>,
  @location(0) viewZ: f32,
  @location(1) targetZ: f32,
  @location(2) color: vec4<f32>,
};

struct ColorData {
    color: vec4<f32>,
};

struct TextureAlpha {
    value: f32
};

@group(0) @binding(0) var<uniform> sceneData: SceneData;
@group(0) @binding(1) var<uniform> sceneLights: SceneLights;
@group(1) @binding(0) var<uniform> myColor: ColorData;
@group(1) @binding(1) var<uniform> textureAlpha: TextureAlpha;
@group(2) @binding(0) var<uniform> myModel: ModelData;
@group(3) @binding(0) var myTexture0: texture_2d<f32>;
@group(3) @binding(1) var myTexture1: texture_2d<f32>;
@group(3) @binding(2) var myTexture2: texture_2d<f32>;
@group(3) @binding(3) var myTexture3: texture_2d<f32>;
@group(3) @binding(4) var mySampler: sampler;

/**
  * Computes the diffuse color for a given point in the scene.
  *
  * @param eye The position of the camera.
  * @param pos The position of the point in the scene.
  * @param normal The normal of the point in the scene.
  * @param sceneLights The lights in the scene.
  * @return The diffuse color for the point.
  */
fn computeDiffuseColor(
    eye: vec3<f32>,
    pos: vec3<f32>,
    normal: vec3<f32>,
    sceneLights: SceneLights) -> vec3<f32> {
  var diffuse: vec3<f32> = sceneLights.ambient.rgb;
  for (var i: u32 = 0; i < MAX_DIR_LIGHTS; i = i + 1) {
    if (sceneLights.dirLights[i].col.a == 0.0) {
      continue;
    }
    let lightDir: vec3<f32> = -normalize(sceneLights.dirLights[i].dir.xyz); //
    let lightColor: vec3<f32> = sceneLights.dirLights[i].col.rgb;
    var NdotL: f32 = max(dot(normal, lightDir), 0);
    let diffuseColor = NdotL * lightColor;

    diffuse = diffuse + diffuseColor;
  }
  for (var i: u32 = 0; i < MAX_POINT_LIGHTS; i = i + 1) {
    if (sceneLights.pointLights[i].col.a == 0.0) {
        continue;
    }
    let dir = sceneLights.pointLights[i].pos.xyz - pos; //  - pos.xyz;
    let attenuation = 1.0 - clamp(pow( length(dir)/50, 2.0), 0.0, 1.0 );

    let lightDir: vec3<f32> = normalize(dir);
    let lightColor: vec3<f32> = sceneLights.pointLights[i].col.rgb;
    var NdotL: f32 = pow(max(dot(normal, lightDir), 0), 2);
    let diffuseColor = NdotL * lightColor;

    diffuse = diffuse + diffuseColor * attenuation;
  }
  return clamp(diffuse, vec3<f32>(0, 0, 0), vec3<f32>(1.0, 1.0, 1.0));
}

/**
  * Computes the diffuse color for a given point in the scene.
  *
  * @param eye The position of the camera.
  * @param pos The position of the point in the scene.
  * @param normal The normal of the point in the scene.
  * @param sceneLights The lights in the scene.
  * @return The diffuse color for the point.
  */
fn computeSpecularColor(
    eye: vec3<f32>,
    pos: vec3<f32>,
    normal: vec3<f32>,
    sceneLights: SceneLights) -> vec3<f32> {
  let shininess: f32 = 64.0;
  var specular: vec3<f32> = vec3<f32>(0, 0, 0);

  for (var i: u32 = 0; i < MAX_POINT_LIGHTS; i = i + 1) {
    if (sceneLights.pointLights[i].col.a == 0.0) {
      continue;
    }
    let dir = sceneLights.pointLights[i].pos.xyz - pos; //  - pos.xyz;
    let attenuation = 1.0 - clamp(pow( length(dir)/14.0, 2.0), 0.0, 1.0 );

    let lightDir: vec3<f32> = normalize(dir);
    let lightColor: vec3<f32> = sceneLights.pointLights[i].col.rgb;

    // Specular
    let V = normalize(pos - eye);
    let R = normalize(reflect(lightDir, normal));
    let specularIntensity = pow(max(dot(V, R), 0.0), shininess);
    let specularColor = specularIntensity * lightColor;

    specular = specular + specularColor * attenuation;
  }

  return clamp(specular, vec3<f32>(0, 0, 0), vec3<f32>(1.0, 1.0, 1.0));
}


/**
  * Computes the distance from a point to a segment.
  *
  * @param point The point.
  * @param segmentStart The start of the segment.
  * @param segmentEnd The end of the segment.
  * @return The distance from the point to the segment.
  */
fn computeDistanceToSegment( point: vec3<f32>, segmentStart: vec3<f32>, segmentEnd: vec3<f32> ) -> f32 {
  let segment = segmentEnd - segmentStart;
  let segmentLength = length(segment);
  let segmentDirection = segment / segmentLength;
  let pointToStart = point - segmentStart;
  let projection = dot(pointToStart, segmentDirection);
  if (projection < 0.0) {
    return length(pointToStart);
  }
  if (projection > segmentLength) {
    return length(point - segmentEnd);
  }
  return length(pointToStart - projection * segmentDirection);
}

fn computeDistanceToCameraAttenuation( d: f32 ) -> f32 {
  if ( d< 50 ) {
    return 1.0;
  }
  return 1 - clamp((d-49)/800 , 0.0, 1.0);
}

// ----------------------------------------------------------------------------------------------- Texture Shaders

@vertex
fn vertexTextureShader(
    @location(0) vertexPosition: vec3<f32>,
    @location(1) vertexTexCoord: vec2<f32>,
    @location(2) vertexNormal: vec3<f32>) -> TextFragment {
  var output: TextFragment;
  var vertex = myModel.model * vec4<f32>(vertexPosition, 1.0);
  var positionInViewSpace = sceneData.view * vertex;

  output.position = sceneData.projection * sceneData.view * vertex;
  output.texCoord = vec2<f32>(vertexTexCoord);
  output.normal = normalize((myModel.modelInverseTranspose * vec4<f32>(vertexNormal, 0.0)).xyz);
  output.pos = vertex.xyz;
  output.eye = sceneData.invertView[3].xyz;
  output.viewZ = -positionInViewSpace.z;

  return output;
}

@fragment
fn fragmentTextureShader(in: TextFragment) -> @location(0) vec4<f32> {
  let diffuse: vec3<f32> = computeDiffuseColor( in.eye, in.pos, in.normal, sceneLights );
  let specular: vec3<f32> = computeSpecularColor( in.eye, in.pos, in.normal, sceneLights );
  let texColor: vec4<f32> = textureSample(myTexture0, mySampler, in.texCoord);
  let att: f32 = computeDistanceToCameraAttenuation(in.viewZ);

  let textMix = vec4<f32>(1-textureAlpha.value);
  let finalColor = mix(texColor, myColor.color, textMix); // mixed the two colors based on alpha.
  return clamp(
    vec4<f32>((finalColor.rgb * diffuse + specular) * att, max(finalColor.a, texColor.a)),
    vec4<f32>(0, 0, 0, 0.0), vec4<f32>(1.0, 1.0, 1.0, 1.0)
  );

}

// ----------------------------------------------------------------------------------------------- Color Shaders

@vertex
fn vertexColorShader(
    @location(0) vertexPosition: vec3<f32>,
    @location(1) vertexNormal: vec3<f32>) -> ColorFragment {
  var output: ColorFragment;
  var vertex = myModel.model * vec4<f32>(vertexPosition, 1.0);
  var positionInViewSpace = sceneData.view * vertex;
  var bias = 0.002 * positionInViewSpace.z;

  var biasedPositionInViewSpace = positionInViewSpace - vec4<f32>(0.0, 0.0, bias, 0.0);

  output.normal = normalize((myModel.modelInverseTranspose * vec4<f32>(vertexNormal, 0.0)).xyz);
  output.position = sceneData.projection * sceneData.view * vertex;
  output.pos = vertex.xyz;
  output.eye = sceneData.invertView[3].xyz;
  output.viewZ = -biasedPositionInViewSpace.z;

  return output;
}

@fragment
fn fragmentColorShader(in: ColorFragment) -> @location(0) vec4<f32> {
  let diffuse: vec3<f32> = computeDiffuseColor( in.eye, in.pos, in.normal, sceneLights );
  let specular: vec3<f32> = computeSpecularColor( in.eye, in.pos, in.normal, sceneLights );
  let att: f32 =  computeDistanceToCameraAttenuation(in.viewZ);

  return clamp(
    vec4<f32>((myColor.color.rgb * diffuse.rgb + specular) * att, myColor.color.a * att),
    vec4<f32>(0, 0, 0, 0.0), vec4<f32>(1.0, 1.0, 1.0, 1.0)
  );

}


@vertex
fn vertexLineShader(
  @location(0) vertexPosition: vec3<f32>,
  @location(1) vertexColor: vec4<f32>
) -> ColorLineFragment {
  var output: ColorLineFragment;
  var vertex = myModel.model * vec4<f32>(vertexPosition, 1.0);

  let eye  = vec4<f32>(sceneData.invertView[3].xyz, 1.0);

  let eyeInViewSpace = sceneData.view * eye;
  let positionInViewSpace = sceneData.view * vertex;
  let bias = 0.002 * positionInViewSpace.z;
  let biasedPositionInViewSpace = positionInViewSpace - vec4<f32>(0.0, 0.0, bias, 0.0);
  output.viewZ = -biasedPositionInViewSpace.z;
  output.targetZ = -eyeInViewSpace.z;
  output.position = sceneData.projection * biasedPositionInViewSpace;
  output.color = vertexColor;

  return output;
}


@fragment
fn fragmentLineShader(in: ColorLineFragment) -> @location(0) vec4<f32> {
  let att: f32 = computeDistanceToCameraAttenuation(in.viewZ);

  return vec4<f32>(in.color.rgb * att, in.color.a * att);
}
`,Ue="",Re=e=>{const{canvas:t,context:r,device:o}=e;let[i,n]=[t.width,t.height];return new ResizeObserver(s=>{const{width:a,height:c}=s[0].contentRect;[i,n]=[Math.round(a),Math.round(c)]}).observe(t.parentElement),s=>{if(i===t.width&&n===t.height){const h=r.getCurrentTexture(),d=s.colorAttachments;return d[0].view=h.createView({label:"ColorView"}),s}t.width=i,t.height=n;const a=o.createTexture({label:"DepthTexture",sampleCount:1,size:[i,n,1],format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT}),c=o.createTexture({label:"ColorTexture",size:{width:i,height:n,depthOrArrayLayers:1},sampleCount:1,format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT}),l=s.colorAttachments;l[0].view=c.createView({label:"ColorView"});const u=s.depthStencilAttachment;return u.view=a.createView({label:"DepthView"}),s}};class Tt{constructor(t,r,o,i){T(this,"canvas"),T(this,"context"),T(this,"device"),T(this,"format"),T(this,"_handleOnRender"),T(this,"_vertexCount",0),T(this,"_activeRenderLoop",!1),T(this,"_pipelineMode","default"),T(this,"_shaderModule"),T(this,"_pipelines",new Map),T(this,"_transformations",{projection:w.identity(),view:w.identity()}),T(this,"_renderPassDescription"),T(this,"_cameraTransHandler"),T(this,"_lightsHandler"),T(this,"_modelHandlers",{}),T(this,"_fps",Ct()),T(this,"_rebuildViewTexture"),T(this,"_ambientLight",[.3,.3,.3,1]),T(this,"_dirLights",[{dir:V.fromValues(0,0,1),col:[.4,.4,.4,0]},{dir:V.fromValues(1,1,1),col:[.4,.3,.3,0]},{dir:V.fromValues(1,0,0),col:[.5,.5,.5,0]},{dir:V.fromValues(-1,-1,-1),col:[.3,.3,.3,0]}]),T(this,"_pointLights",[{pos:y.fromValues(-12,12,8),col:[.5,.5,.2,0]},{pos:y.fromValues(12,12,8),col:[.4,.2,.2,0]},{pos:y.fromValues(-12,-12,8),col:[.2,.2,.5,0]},{pos:y.fromValues(12,-12,8),col:[.5,.1,.5,0]}]),T(this,"render",()=>{const{device:n}=this;this._vertexCount=0,this._handleOnRender&&this._handleOnRender(this);let s=this._renderPassDescription??Lt(this);this._rebuildViewTexture&&(this._renderPassDescription=this._rebuildViewTexture(s));const a=n.createCommandEncoder(),c=a.beginRenderPass(s),l=this._fps.getLastTimeSpan();this.updateLights(l),this.pipelines.filter(({geoRenderable:u})=>u.colors[0][3]===1).forEach((u,h)=>{this.renderPipeline(u,h,c,l)}),this.pipelines.filter(({geoRenderable:u})=>u.colors[0][3]<1).forEach((u,h)=>{this.renderPipeline(u,h,c,l)}),c.end(),n.queue.submit([a.finish()])}),this.canvas=t,this.context=r,this.device=o,this.format=i,this._rebuildViewTexture=Re(this),this.device.lost.then(()=>{console.log("WebGPU:device lost")})}get vertexCount(){return this._vertexCount}get fps(){return this._fps.getFPS()}get dirLights(){return this._dirLights}get pontLights(){return this._pointLights}setAmbientLight(t){this._ambientLight=t}setLight(t,r,o){switch(t){case"directional":this._dirLights[r]=o;break;case"point":this._pointLights[r]=o;break}}static async build(t){return Pe(t).then(({canvas:r,context:o,device:i,format:n})=>new Tt(r,o,i,n))}setPipelineMode(t){this._pipelineMode=t}get pipelines(){return[...this._pipelines.values()]}getScene(){return[...this._pipelines.values()].map(({geoRenderable:t})=>t)}async setupShaders(t){if(this._shaderModule)return this;let r;if(Ce(t))switch(t){case"standard-3d":r=Ee;break;case"standard-2d":default:r=Ue;break}else r=t.source;return this._shaderModule=await Se(this,r),this}setScene(t){if(!this._shaderModule)throw new Error("WebGPU:shader module is NOT available!");t.forEach(r=>{r.buildGpuBuffer(this)}),this._pipelines=At(this,this._shaderModule,t),this._renderPassDescription=Lt(this)}addToScene(t){if(!this._shaderModule)throw new Error("WebGPU:shader module is NOT available!");t.forEach(r=>{r.buildGpuBuffer(this)}),At(this,this._shaderModule,t).forEach((r,o)=>{this._pipelines.set(o,r)})}removeFromScene(t){return this._pipelines.delete(t)}clearScene(){this._pipelines.clear()}captureMouseMotion(t){De(this.canvas,{move:(t==null?void 0:t.move)??((r,o,i)=>{}),click:(t==null?void 0:t.click)??((r,o)=>{}),zoom:(t==null?void 0:t.zoom)??(r=>{}),tilt:(t==null?void 0:t.tilt)??(r=>{})})}sceneIntoBuffer(t){const{device:r}=this,{projection:o,view:i}=this._transformations,n=i.invert();let s=0;r.queue.writeBuffer(t[0],s,i.buffer()),s+=w.bufferSize,r.queue.writeBuffer(t[0],s,n.buffer()),s+=w.bufferSize,r.queue.writeBuffer(t[0],s,o.buffer()),s+=w.bufferSize;let a=0;const c=new Float32Array(this._dirLights.flatMap(({dir:h,col:d})=>[...h.coordinates,...d]));r.queue.writeBuffer(t[1],a,c),a+=c.byteLength;const l=new Float32Array(this._pointLights.flatMap(({pos:h,col:d})=>[...h.coordinates,...d]));r.queue.writeBuffer(t[1],a,l),a+=l.byteLength;const u=new Float32Array(this._ambientLight);r.queue.writeBuffer(t[1],a,u)}updateLights(t){if(!this._lightsHandler)return;const{dirLights:r,posLights:o}=this._lightsHandler;r&&r(t,this._dirLights),o&&o(t,this._pointLights)}onRender(t){this._handleOnRender=t}renderPipeline(t,r,o,i){const{pipeline:n,altPipeline:s,uniformBuffers:a,bindGroups:c,geoRenderable:l}=t,{device:u}=this;r===0&&(this.sceneIntoBuffer(a.sceneBuffers),o.setBindGroup(0,c.sceneGroup));const h=this._pipelineMode==="default"?n:s;o.setPipeline(h),this._modelHandlers[l.id]&&l.transform(i,this._modelHandlers[l.id]),u.queue.writeBuffer(a.modelBuffers[0],0,l.transformationData),o.setBindGroup(2,c.modelGroup),c.texturesGroup&&o.setBindGroup(3,c.texturesGroup),l.buffers.forEach((d,p)=>{const v=new Float32Array(l.colors[p]);u.queue.writeBuffer(a.colorBuffers[0],0,v),u.queue.writeBuffer(a.colorBuffers[1],0,new Float32Array([l.textureAlpha])),o.setBindGroup(1,c.colorGroup);const f=l.getVertexCountPerStrip(p);this._vertexCount+=f,o.setVertexBuffer(0,d),o.draw(f)})}renderLoop(){const{width:t,height:r}=this.canvas;this._transformations=Le(this._transformations,[t,r],this._cameraTransHandler),this.render(),this._fps.measureFPS(),this._activeRenderLoop&&requestAnimationFrame(this.renderLoop.bind(this))}beginRenderLoop(t){this._fps=Ct(),this._cameraTransHandler=t==null?void 0:t.camera,this._lightsHandler=t==null?void 0:t.lights,this._modelHandlers=(t==null?void 0:t.models)??{},this._activeRenderLoop=!0,this.renderLoop()}endRenderLoop(){this._activeRenderLoop=!1}}let nt=new Map;const Ne=async e=>{var t,r;if(!navigator.gpu)return Promise.reject(new Error("WebGPU is not supported in this browser!"));const o=(t=nt.get(e.id))==null?void 0:t.gpu;if(o)return Promise.resolve(o);if((r=nt.get(e.id))!=null&&r.initializing)return new Promise((n,s)=>{setTimeout(()=>{var a;const c=(a=nt.get(e.id))==null?void 0:a.gpu;if(c)return console.warn("WebGPU connection already initialized. Reusing previous connection."),n(c);s(new Error("WebGPU already initialization is taking too long!"))},100)});nt.set(e.id,{initializing:!0});const i=await Tt.build(e);return nt.set(e.id,{initializing:!1,gpu:i}),Promise.resolve(i)},Ze=(e,t,r)=>{const{device:o}=e,i="rgba8unorm",n={label:t,size:[r.width,r.height,1],format:i,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT},s=o.createTexture(n);o.queue.copyExternalImageToTexture({source:r},{texture:s},[r.width,r.height]);const a=s.createView({label:`${t}-view`});return{name:t,textures:[s],views:[a]}},Oe=e=>{let t=[];const r=/rgba?\(([^)]+)\)/.exec(e);if(r&&r[1]&&(t=r[1].split(",").map(a=>parseFloat(a.trim()))),t.length<3)throw new Error("Invalid RGB/RGBA format");const o=t[0]/255,i=t[1]/255,n=t[2]/255,s=t.length===4?t[3]:1;return{r:o,g:i,b:n,a:s}},ke=async(e,t)=>{const r=new URL(t,window.location.href);return new Promise((o,i)=>{const n=new Image;n.src=r.href,n.onerror=s=>{i(s)},n.onload=()=>{createImageBitmap(n).then(s=>Ze(e,r.pathname,s)).then(s=>o([e,s]))}})},qe=async(e,t)=>Promise.all(t.map(r=>ke(e,r))).then(r=>Promise.resolve([e,r.map(([,o])=>o)])),J=4;class ft{constructor(t,r,o){T(this,"_body",null),T(this,"_id"),T(this,"_bufferData",null),T(this,"_vertices",[]),T(this,"_vertexColors",[]),T(this,"_vertexNormals",[]),T(this,"_vertexTextureCoords",[]),T(this,"_stripColors",[]),T(this,"_textureAlpha",1),T(this,"_vertexByteSize",0),T(this,"_buffers",[]),T(this,"_bufferLayout",null),T(this,"_topology","triangle-list"),T(this,"_cullMode","back"),T(this,"_material",null),T(this,"_transformation",{rotation:j.identity(),scale:C.fromValues(1,1,1),translation:C.fromValues(0,0,0)}),this._id=t,this._topology=r,this._vertexByteSize=3*4,this._stripColors=o.colors??[[0,0,0,0]],this._textureAlpha=o.textureAlpha??1}get id(){return this._id}get textureAlpha(){return this._textureAlpha}get label(){return this._topology}get translationVector(){return this._transformation.translation??C.fromValues(0,0,0)}get orientationRotation(){return this._transformation.rotation??j.identity()}get scaleVector(){return this._transformation.scale??C.fromValues(1,1,1)}get hasTextures(){return this._vertexTextureCoords.length>0&&this._material!==null}get material(){return this._material}get vertexShader(){return this._topology==="triangle-strip"||this._topology==="triangle-list"?this.hasTextures?"vertexTextureShader":"vertexColorShader":"vertexLineShader"}get fragmentShader(){return this._topology==="triangle-strip"||this._topology==="triangle-list"?this.hasTextures?"fragmentTextureShader":"fragmentColorShader":"fragmentLineShader"}get colors(){return this._stripColors}get primitives(){return this._topology}get cullMode(){return this._topology==="triangle-strip"||this._topology==="triangle-list"?this._cullMode:"none"}get vertexCount(){return this._vertices.reduce((t,r)=>t+r.length/3,0)}get body(){return this._body}get transformation(){return w.fromRotationTranslationScale(this._transformation.rotation??j.identity(),this._transformation.translation??C.fromValues(0,0,0),this._transformation.scale??C.fromValues(1,1,1))}get transformationData(){const t=this.transformation;return new Float32Array([...t.values,...t.transpose().invert().values])}setMaterial(t){this._material=t}setBody(t){return this._body=t,this}scale(t){return this._transformation.scale=this.scaleVector.multiply(t),this}translate(t){return this._transformation.translation=this.translationVector.add(t),this}rotate(t){return this._transformation.rotation=this.orientationRotation.compose(t),this}rotoTranslate(t,r){const o=this._transformation;return o.rotation=t,o.translation=r,this}transform(t,r){return this._transformation=r(t,this._transformation),this}getVertexCountPerStrip(t){return this._vertices[t].length/3}get vertexByteSize(){return this._vertexByteSize}getByteSizePerStrip(t=0){return this._vertices[t].length*J+(this._vertexColors.length>0?this._vertexColors[t].length*J:0)+(this._vertexNormals.length>0?this._vertexNormals[t].length*J:0)+(this._vertexTextureCoords.length>0?this._vertexTextureCoords[t].length*J:0)}setCullMode(t){return this._cullMode=t,this}addVertices(t){this._vertices.push(t)}getBufferData(){return this._bufferData!==null?this._bufferData:(this._bufferData=this._vertices.map((t,r)=>{const o=[];for(let i=0,n=0,s=0,a=0;i<t.length;i+=3,n+=4,s+=3,a+=2){const c=[t[i+0],t[i+1],t[i+2]];this._vertexColors.length>r&&(c.push(this._vertexColors[r][n+0]),c.push(this._vertexColors[r][n+1]),c.push(this._vertexColors[r][n+2]),c.push(this._vertexColors[r][n+3])),this._vertexTextureCoords.length>r&&(c.push(this._vertexTextureCoords[r][a+0]),c.push(this._vertexTextureCoords[r][a+1])),this._vertexNormals.length>r&&(c.push(this._vertexNormals[r][s+0]),c.push(this._vertexNormals[r][s+1]),c.push(this._vertexNormals[r][s+2])),o.push(...c)}return new Float32Array(o)}),this._bufferData)}get layouts(){let t=0,r=0;const o=[{shaderLocation:t,offset:0,format:"float32x3"}];return t+=1,r+=3*J,this._vertexColors.length>0&&(o.push({shaderLocation:t,offset:r,format:"float32x4"}),t+=1,r+=4*J),this._vertexTextureCoords.length>0&&(o.push({shaderLocation:t,offset:r,format:"float32x2"}),t+=1,r+=2*J),this._vertexNormals.length>0&&(o.push({shaderLocation:t,offset:r,format:"float32x3"}),t+=1,r+=3*J),o}get buffers(){return this._buffers}get bufferLayout(){if(this._bufferLayout===null)throw new Error("TriangleData: Buffer layout is not available! - Did you call buildGpuBuffer() ?");return this._bufferLayout}buildGpuBuffer(t){this._buffers=this.getBufferData().map(r=>Te(t.device,r)),this._bufferLayout={arrayStride:this.vertexByteSize,attributes:this.layouts}}addColors(t){this._vertexColors.length===0&&(this._vertexByteSize+=4*4),this._vertexColors.push(t)}addNormals(t){var r;this._vertexNormals.length===0&&(this._vertexByteSize+=3*4),(r=this._vertexNormals)==null||r.push(t)}addTextures(t){this._vertexTextureCoords.length===0&&(this._vertexByteSize+=2*4),this._vertexTextureCoords.push(t)}}const rt=(e,t,r)=>{const{w:o,h:i}=t,n=o/2,s=i/2,a=e.origin,c=[],l=[],u=V.fromValues(0,0,1);c.push(y.fromValues(a.x-n,a.y-s,0)),c.push(y.fromValues(a.x+n,a.y-s,0)),c.push(y.fromValues(a.x-n,a.y+s,0)),c.push(y.fromValues(a.x-n,a.y+s,0)),c.push(y.fromValues(a.x+n,a.y-s,0)),c.push(y.fromValues(a.x+n,a.y+s,0)),l.push(u,u,u,u,u,u);const h=[],{pos:d,size:p}=r,{w:v,h:f}=p,m=v/2,b=f/2;h.push({u:d.u+m,v:d.v-b}),h.push({u:d.u-m,v:d.v-b}),h.push({u:d.u+m,v:d.v+b}),h.push({u:d.u+m,v:d.v+b}),h.push({u:d.u-m,v:d.v-b}),h.push({u:d.u-m,v:d.v+b});const S=c.map(g=>g.absolute(e)),_=l.map(g=>g.absolute(e));return[S,_,h]},ot=(e,t)=>[e[0].map(r=>r.map(t).triplet).flat(),e[1].map(r=>r.map(t).triplet).flat(),e[2].map(r=>[r.u,r.v]).flat()],He=(e,t)=>{const{id:r,textureCoordinates:o}=t,i=w.rotationX(U(-90)),n=w.rotationX(U(180)),s=w.rotationX(U(90)),a=w.rotationZ(U(-90)).rotationY(U(90)),c=w.rotationZ(U(90)).rotationY(U(-90)),l=Vt.from2Vectors(y.fromValues(0,0,.5),V.fromValues(0,0,1),V.fromValues(1,0,0)),u=l.map(n),h=l.map(i),d=l.map(s),p=l.map(a),v=l.map(c),f={w:.25,h:.25},m=rt(l,{w:1,h:1},{pos:{u:.25+.25/2,v:.25/2},size:f}),b=rt(u,{w:1,h:1},{pos:{u:.25+.25/2,v:.5+.25/2},size:f}),S=rt(h,{w:1,h:1},{pos:{u:.25+.25/2,v:.25+.25/2},size:f}),_=rt(d,{w:1,h:1},{pos:{u:.75+.25/2,v:.25+.25/2},size:f}),g=rt(p,{w:1,h:1},{pos:{u:0+.25/2,v:.25+.25/2},size:f}),M=rt(v,{w:1,h:1},{pos:{u:.5+.25/2,v:.25+.25/2},size:f}),[x,A,B]=ot(m,e),N=ot(b,e),Z=ot(S,e),O=ot(_,e),k=ot(g,e),q=ot(M,e);x.push(...N[0],...Z[0],...O[0],...k[0],...q[0]),A.push(...N[1],...Z[1],...O[1],...k[1],...q[1]),B.push(...N[2],...Z[2],...O[2],...k[2],...q[2]);const P=new ft(r,"triangle-list",t);return P.addVertices(new Float32Array(x)),P.addNormals(new Float32Array(A)),o&&P.addTextures(new Float32Array(B)),P},$e=()=>He,zt=(e,t,r)=>{const o=V.fromValues(0,0,1),i=V.fromValues(0,0,-1),n=[],s=[],a=r==="up"?0:Math.PI*2,c=r==="up"?Math.PI/e:-Math.PI/e,l=r==="up"?u=>u<Math.PI*2:u=>u>0;for(let u=a;l(u);u+=c){const h=y.fromValues(0,0,t),d=y.fromValues(.5*Math.cos(u),.5*Math.sin(u),t),p=y.fromValues(.5*Math.cos(u+c),.5*Math.sin(u+c),t);s.push(h),s.push(d),s.push(p),r==="up"?n.push(o,o,o):n.push(i,i,i)}return[s,n]},Ye=(e,t,r)=>{const o=[],i=[],n=Math.PI/e,s=y.fromValues(0,0,t),a=y.fromValues(0,0,r);for(let c=0;c<Math.PI*2;c+=n){const l=y.fromValues(.5*Math.cos(c),.5*Math.sin(c),t),u=V.fromPoints(l,s);o.push(l),i.push(u);const h=y.fromValues(.5*Math.cos(c+n),.5*Math.sin(c+n),t),d=V.fromPoints(h,s);o.push(h),i.push(d);const p=y.fromValues(.5*Math.cos(c),.5*Math.sin(c),r),v=V.fromPoints(p,a);o.push(p),i.push(v);const f=y.fromValues(.5*Math.cos(c),.5*Math.sin(c),r),m=V.fromPoints(f,a);o.push(f),i.push(m);const b=y.fromValues(.5*Math.cos(c+n),.5*Math.sin(c+n),t),S=V.fromPoints(b,s);o.push(b),i.push(S);const _=y.fromValues(.5*Math.cos(c+n),.5*Math.sin(c+n),r),g=V.fromPoints(_,a);o.push(_),i.push(g)}return[o,i]},je=(e,t)=>{const{steps:r,id:o,textureCoordinates:i}=t,n=[],s=[],a=[],[c,l]=zt(r,.5,"up"),[u,h]=zt(r,-.5,"down"),[d,p]=Ye(r,-.5,.5);if(n.push(...c.map(f=>f.map(e))),n.push(...u.map(f=>f.map(e))),n.push(...d.map(f=>f.map(e))),i){let f=0,m=0;const b=c.map(g=>[g.x+.5,g.y+.5]),S=u.map(g=>[g.x+.5,g.y+.5]),_=d.map(g=>{const M=g.z+.5;let x=(Math.atan2(g.y,g.x)+Math.PI)/(2*Math.PI);return x<Math.min(f,m)&&(x+=1),m=f,f=x,[x,M]});a.push(...b),a.push(...S),a.push(..._)}s.push(...l.map(f=>f.map(e))),s.push(...h.map(f=>f.map(e))),s.push(...p.map(f=>f.map(e)));const v=new ft(o,"triangle-list",t);return v.addVertices(new Float32Array(n.map(f=>f.triplet).flat())),v.addNormals(new Float32Array(s.map(f=>f.triplet).flat())),i&&v.addTextures(new Float32Array(a.flat())),v},Xe=()=>je,D=.5257311121191336,E=.8506508083520399,We=[V.fromValues(-D,0,E),V.fromValues(D,0,E),V.fromValues(-D,0,-E),V.fromValues(D,0,-E),V.fromValues(0,E,D),V.fromValues(0,E,-D),V.fromValues(0,-E,D),V.fromValues(0,-E,-D),V.fromValues(E,D,0),V.fromValues(-E,D,0),V.fromValues(E,-D,0),V.fromValues(-E,-D,0)],Ke=[[0,4,1],[0,9,4],[9,5,4],[4,5,8],[4,8,1],[8,10,1],[8,3,10],[5,3,8],[5,2,3],[2,7,3],[7,10,3],[7,6,10],[7,11,6],[11,0,6],[0,1,6],[6,1,10],[9,0,11],[9,11,2],[9,2,5],[7,2,11]];function Qe(e,t){return V.fromVector(e.add(t))}function Ht(e,t,r=1){const o=new Map,i=[];function n(s,a){const c=s<a,l=`${c?s:a}-${c?a:s}`,u=o.get(l);if(u)return u;const h=Qe(C.fromValues(...e[s].triplet),C.fromValues(...e[a].triplet));e.push(h);const d=e.length-1;return o.set(l,d),d}for(const[s,a,c]of t){const l=n(s,a),u=n(s,c),h=n(a,c);i.push([s,l,u]),i.push([a,h,l]),i.push([c,u,h]),i.push([l,h,u])}return r===1?[e,i]:Ht(e,i,r-1)}const mt=e=>{let t=Math.asin(e.z);return[(Math.atan2(e.y,e.x)+Math.PI)/(2*Math.PI),.5-t/Math.PI]},Je=(e,t)=>{const{steps:r,id:o,textureCoordinates:i}=t,[n,s]=Ht(We,Ke,r),a=[],c=[],l=[],u=y.fromValues(0,0,0);s.forEach(d=>{const p=y.fromVector(n[d[2]]),v=y.fromVector(n[d[1]]),f=y.fromVector(n[d[0]]),m=V.fromVector(C.fromPoints(p,u)),b=V.fromVector(C.fromPoints(v,u)),S=V.fromVector(C.fromPoints(f,u));if(a.push(...p.map(e).triplet),a.push(...v.map(e).triplet),a.push(...f.map(e).triplet),c.push(...m.triplet),c.push(...b.triplet),c.push(...S.triplet),i){const _=mt(m),g=mt(b),M=mt(S),x=Math.min(_[0],g[0],M[0]),A=Math.max(_[0],g[0],M[0]);Math.abs(A-x)>.8&&(_[0]<.4&&g[0]<.4?M[0]-=1:_[0]<.4&&M[0]<.4?g[0]-=1:g[0]<.4&&M[0]<.4?_[0]-=1:_[0]>.6&&g[0]>.6?M[0]+=1:_[0]>.6&&M[0]>.6?g[0]+=1:g[0]>.6&&M[0]>.6&&(_[0]+=1)),l.push(..._),l.push(...g),l.push(...M)}});const h=new ft(o,"triangle-list",t);return h.addVertices(new Float32Array(a)),h.addNormals(new Float32Array(c)),i&&h.addTextures(new Float32Array(l)),h},Gt=()=>Je,tr=(e,t)=>{var r,o,i,n;const{id:s}=t,a=e.scaleVector,c=(r=t.colors)!=null&&r[0]?t.colors[0][3]/2:.8,l=Math.min(a.x,a.y),u=Math.log10(l),h=Math.max(.9-(u-Math.floor(u)),c/2),d=Math.max(Math.min(.9,h*2),c),p=(o=t.colors)!=null&&o[0]?t.colors[0][3]/2:h*.5,v=Math.floor(u)-2,f=Math.floor(u)-1,m=Math.floor(u),b=Math.pow(10,Math.round(f)),S=Math.pow(10,Math.round(m))/2,_=Math.pow(10,Math.round(v));console.log("prev tileDim",_,"with total grids",l/_," with alpha",p),console.log("main tileDim",b,"with total grids",l/b," with alpha",h),console.log("next tileDim",S,"with total grids",l/S," with alpha",d);const g=vt(a,b,e),M=vt(a,S,e),x=new ft(s,"line-list",t);if(t.showAxes){const A=[],B=y.fromValues(-.5,0,0).map(e),N=y.fromValues(.5,0,0).map(e),Z=y.fromValues(0,-.5,0).map(e),O=y.fromValues(0,.5,0).map(e),k=y.fromValues(0,0,0).map(e),q=y.fromValues(0,0,b);A.push(B,N,Z,O,k,q);const P=[[1,0,0,1],[1,0,0,1],[0,1,0,1],[0,1,0,1],[.1,.1,1,1],[.1,.1,1,1]];x.addVertices(new Float32Array(A.flatMap(jt=>jt.triplet))),x.addColors(new Float32Array(P.flat()))}if(x.addVertices(new Float32Array(M.flatMap(A=>A.triplet))),x.addColors(new Float32Array(gt(M,d))),x.addVertices(new Float32Array(g.flatMap(A=>A.triplet))),x.addColors(new Float32Array(gt(g,h,(i=t.colors)==null?void 0:i[0]))),l/_<100){const A=vt(a,_,e);x.addVertices(new Float32Array(A.flatMap(B=>B.triplet))),x.addColors(new Float32Array(gt(A,p,(n=t.colors)==null?void 0:n[0])))}return x},er=()=>tr,vt=(e,t,r)=>{const o=e.x/t,i=e.y/t,n=1/o,s=1/i,a=[];for(let c=0;c<o/2;c++){const l=y.fromValues(-n*c,-.5,0).map(r),u=y.fromValues(-n*c,.5,0).map(r);if(a.push(l,u),n*(c+1)<.5){const h=y.fromValues(n*(c+1),-.5,0).map(r),d=y.fromValues(n*(c+1),.5,0).map(r);a.push(h,d)}}for(let c=0;c<i/2;c++){const l=y.fromValues(-.5,-s*c,0).map(r),u=y.fromValues(.5,-s*c,0).map(r);if(a.push(l,u),s*(c+1)<.5){const h=y.fromValues(-.5,s*(c+1),0).map(r),d=y.fromValues(.5,s*(c+1),0).map(r);a.push(h,d)}}return a};function gt(e,t,r){return e.flatMap(()=>r?[r[0],r[1],r[2],t]:[.9,.9,1,t])}const rr=(e,t=[10,10,10])=>{let r=y.fromValues(0,0,0),o=y.fromValues(...t),i=o.x===0&&o.y===0?V.fromValues(0,1,0):V.fromValues(0,0,1),n=[0,0],s=[0,0],a=0,c=0,l=Math.PI/5,u=C.fromPoints(o,r).lengthSquare,h=Vt.lookAt(o,r,i),d=!1;return[{move:(p,v,f)=>{const m=Math.min(e.canvas.width,e.canvas.height),b=Math.max(e.canvas.width,e.canvas.height);let S=Math.log(u)*Math.atan(l)/(b/2),_=l/m*2;switch(p){case"mouse-0":n=[v.direction[0]*S,v.direction[1]*S],d=!0;break;case"mouse-1":s=[-v.direction[0]*_,v.direction[1]*_];break;case"mouse-2":l+=v.direction[1]*_;break;case"none":d=!1;break}},zoom:p=>{const v=Math.log10(u+1)/(1e3*Math.atan(l));a=p*v},tilt:p=>{c=p*5e-4,d=!1}},{view:p=>{if(!p||p!=null&&p.isIdentity)return w.lookAt(o,r,i);const v=C.fromPoints(o,r).scale(1-a);v.length>2&&v.length<500&&(o=r.add(v));const f=C.fromPoints(r,o),m=w.move(f).apply(h),b=[Math.tan(s[0])*u,Math.tan(s[1])*u],S=C.fromValues(b[0],b[1],0).absolute(m),_=m.relative(o);let g=m.relative(i);g=w.rotationZ(c).apply(g);const M=w.rotationX(-n[1]).compose(w.rotationY(-n[0]));o=M.apply(_).absolute(m),i=M.apply(g).absolute(m);const x=w.move(S);return r=x.apply(r),o=x.apply(o),h=Vt.lookAt(o,r,i),d||(n=[n[0]*.95,n[1]*.95],c*=.9,a*=.9,Math.abs(n[0])<.001&&Math.abs(n[1])<.001&&Math.abs(c)<.001&&Math.abs(a)<.001&&(n=[0,0],c=0,a=0)),s=[0,0],u=C.fromPoints(o,r).length,h.toTransform()},projection:p=>{const v=e.canvas.width/e.canvas.height,f=C.fromPoints(o,r).length,m=Math.max(400,f*.8);return w.perspective(l,v,Math.max(.01,f-m),f+m)}}]},or=e=>{const t=-U(9),r=y.fromValues(10,0,-1.5),o=y.fromValues(-12,0,-3);e.setAmbientLight([0,0,0,1]);const i=V.fromVector(y.origin().subtract(r));return e.setLight("directional",0,{dir:i,col:[.6,.6,.6,1]}),e.setLight("directional",1,{dir:i,col:[.6,.6,.6,0]}),e.setLight("point",0,{pos:r,col:[.8,.8,.8,1]}),e.setLight("point",1,{pos:o,col:[.2,.2,.5,1]}),e.setLight("point",2,{pos:o,col:[.1,.1,.4,0]}),e.setLight("point",3,{pos:o,col:[.1,.1,.4,0]}),{dirLights:(n,s)=>{const a=n/1e3,c=w.rotationZ(t*a);s[0].dir=s[0].dir.map(c)},posLights:(n,s)=>{const a=n/1e3,c=w.rotationZ(t*a),l=w.rotationZ(t*a*1.2);s[0].pos=s[0].pos.map(c),s[1].pos=s[1].pos.map(l)}}};let W=0,It=0;const ir=e=>({"earth-clouds":t=>{const r=-t/1e3;return It+=r*U(360/240),{rotation:j.rotationZ(It)}},"earth-sphere":t=>{const r=-t/1e3;return W+=r*U(360/180),{rotation:j.rotationZ(W)}},cylinder:t=>{const r=t/1e3;return W+=r*U(360/20),{rotation:j.rotationZ(W).compose(j.rotationY(W))}},cube:t=>{const r=t/1e3;return W+=r*U(360/10),{rotation:j.rotationZ(W).compose(j.rotationY(W)).compose(j.rotationZ(W))}}}),nr=(e,t)=>{const r=Gt()(w.scale(2.5,2.5,2.5),{id:"earth-sphere",steps:4,colors:[[.5,.5,.5,1]],textureCoordinates:!0});r.setMaterial(e);const o=Gt()(w.scale(2.505,2.505,2.505),{id:"earth-clouds",steps:4,colors:[[.5,.5,.5,1]],textureCoordinates:!0});return o.setMaterial(t),[r,o]},sr=e=>{const t=Xe()(w.scale(2,2,2),{id:"cylinder",steps:24,colors:[[1,0,0,1]],textureCoordinates:!0});return t.setMaterial(e),[t]},ar=e=>{const t=$e()(w.scale(2,2,2),{id:"cube",textureCoordinates:!0});return t.setMaterial(e),[t]},$t=()=>[er()(w.scale(50,50,1).translation(0,0,0),{id:"ref-plane",colors:[[.2,.2,.3,.4]]})];async function cr(e,t){const r=await Ne(e);await r.setupShaders("standard-3d");const[o,i]=rr(r,[6,6,4]);r.captureMouseMotion(o);const n=or(r),s=ir();r.beginRenderLoop({camera:i,lights:n,models:s});const a=await $t();return r.setScene(a),r}const st=[];let Yt=!1;const ur=(e,t)=>()=>{console.log("setWireframe",t.checked),t.checked?e.setPipelineMode("alternative"):e.setPipelineMode("default")},lr=e=>()=>{console.log("setGrid",e.checked),Yt=e.checked},_t=(e,t)=>()=>{e.clearScene();const r=Yt?$t():[];switch(t){case"globe":const o=nr(st[0],st[3]);e.setScene([...o,...r]);break;case"cylinder":const i=sr(st[1]);e.setScene([...i,...r]);break;case"cube":const n=ar(st[2]);e.setScene([...r,...n]);break}},yt=document.getElementById("support"),Ft=document.getElementById("gfx-canvas");!yt||!Ft?alert("The app is broken! No canvas was found!"):cr(Ft).then(e=>qe(e,["earth.jpg","metal2.jpg","dice.png","clouds-2k.png"])).then(([e,t])=>{st.push(...t);const r=document.getElementById("wireframe");r.onclick=ur(e,r);const o=document.getElementById("grid");o.onclick=lr(o);const i=document.getElementById("geo-globe"),n=document.getElementById("geo-cylinder"),s=document.getElementById("geo-cube");i.onclick=_t(e,"globe"),n.onclick=_t(e,"cylinder"),s.onclick=_t(e,"cube"),i.click(),yt.innerText="All set!"}).catch(e=>{yt.innerText="Error: "+e.message});
