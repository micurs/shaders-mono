(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))i(o);new MutationObserver(o=>{for(const n of o)if(n.type==="childList")for(const s of n.addedNodes)s.tagName==="LINK"&&s.rel==="modulepreload"&&i(s)}).observe(document,{childList:!0,subtree:!0});function r(o){const n={};return o.integrity&&(n.integrity=o.integrity),o.referrerPolicy&&(n.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?n.credentials="include":o.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function i(o){if(o.ep)return;o.ep=!0;const n=r(o);fetch(o.href,n)}})();var At=Object.defineProperty,Bt=(e,t,r)=>t in e?At(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,C=(e,t,r)=>(Bt(e,typeof t!="symbol"?t+"":t,r),r),it=1e-6,G=typeof Float32Array<"u"?Float32Array:Array;Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});function xt(){var e=new G(9);return G!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}function It(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e}function O(){var e=new G(16);return G!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function U(e){var t=new G(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function Dt(e,t,r,i,o,n,s,a,c,u,l,h,f,p,v,g){var d=new G(16);return d[0]=e,d[1]=t,d[2]=r,d[3]=i,d[4]=o,d[5]=n,d[6]=s,d[7]=a,d[8]=c,d[9]=u,d[10]=l,d[11]=h,d[12]=f,d[13]=p,d[14]=v,d[15]=g,d}function ut(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function Et(e,t){if(e===t){var r=t[1],i=t[2],o=t[3],n=t[6],s=t[7],a=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=r,e[6]=t[9],e[7]=t[13],e[8]=i,e[9]=n,e[11]=t[14],e[12]=o,e[13]=s,e[14]=a}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}function T(e,t){var r=t[0],i=t[1],o=t[2],n=t[3],s=t[4],a=t[5],c=t[6],u=t[7],l=t[8],h=t[9],f=t[10],p=t[11],v=t[12],g=t[13],d=t[14],M=t[15],L=r*a-i*s,V=r*c-o*s,y=r*u-n*s,b=i*c-o*a,x=i*u-n*a,Y=o*u-n*c,j=l*g-h*v,W=l*d-f*v,Z=l*M-p*v,K=h*d-f*g,Q=h*M-p*g,J=f*M-p*d,z=L*J-V*Q+y*K+b*Z-x*W+Y*j;return z?(z=1/z,e[0]=(a*J-c*Q+u*K)*z,e[1]=(o*Q-i*J-n*K)*z,e[2]=(g*Y-d*x+M*b)*z,e[3]=(f*x-h*Y-p*b)*z,e[4]=(c*Z-s*J-u*W)*z,e[5]=(r*J-o*Z+n*W)*z,e[6]=(d*y-v*Y-M*V)*z,e[7]=(l*Y-f*y+p*V)*z,e[8]=(s*Q-a*Z+u*j)*z,e[9]=(i*Z-r*Q-n*j)*z,e[10]=(v*x-g*y+M*L)*z,e[11]=(h*y-l*x-p*L)*z,e[12]=(a*W-s*K-c*j)*z,e[13]=(r*K-i*W+o*j)*z,e[14]=(g*V-v*b-d*L)*z,e[15]=(l*b-h*V+f*L)*z,e):null}function lt(e,t,r){var i=t[0],o=t[1],n=t[2],s=t[3],a=t[4],c=t[5],u=t[6],l=t[7],h=t[8],f=t[9],p=t[10],v=t[11],g=t[12],d=t[13],M=t[14],L=t[15],V=r[0],y=r[1],b=r[2],x=r[3];return e[0]=V*i+y*a+b*h+x*g,e[1]=V*o+y*c+b*f+x*d,e[2]=V*n+y*u+b*p+x*M,e[3]=V*s+y*l+b*v+x*L,V=r[4],y=r[5],b=r[6],x=r[7],e[4]=V*i+y*a+b*h+x*g,e[5]=V*o+y*c+b*f+x*d,e[6]=V*n+y*u+b*p+x*M,e[7]=V*s+y*l+b*v+x*L,V=r[8],y=r[9],b=r[10],x=r[11],e[8]=V*i+y*a+b*h+x*g,e[9]=V*o+y*c+b*f+x*d,e[10]=V*n+y*u+b*p+x*M,e[11]=V*s+y*l+b*v+x*L,V=r[12],y=r[13],b=r[14],x=r[15],e[12]=V*i+y*a+b*h+x*g,e[13]=V*o+y*c+b*f+x*d,e[14]=V*n+y*u+b*p+x*M,e[15]=V*s+y*l+b*v+x*L,e}function X(e,t,r){var i=r[0],o=r[1],n=r[2],s,a,c,u,l,h,f,p,v,g,d,M;return t===e?(e[12]=t[0]*i+t[4]*o+t[8]*n+t[12],e[13]=t[1]*i+t[5]*o+t[9]*n+t[13],e[14]=t[2]*i+t[6]*o+t[10]*n+t[14],e[15]=t[3]*i+t[7]*o+t[11]*n+t[15]):(s=t[0],a=t[1],c=t[2],u=t[3],l=t[4],h=t[5],f=t[6],p=t[7],v=t[8],g=t[9],d=t[10],M=t[11],e[0]=s,e[1]=a,e[2]=c,e[3]=u,e[4]=l,e[5]=h,e[6]=f,e[7]=p,e[8]=v,e[9]=g,e[10]=d,e[11]=M,e[12]=s*i+l*o+v*n+t[12],e[13]=a*i+h*o+g*n+t[13],e[14]=c*i+f*o+d*n+t[14],e[15]=u*i+p*o+M*n+t[15]),e}function Rt(e,t,r){var i=r[0],o=r[1],n=r[2];return e[0]=t[0]*i,e[1]=t[1]*i,e[2]=t[2]*i,e[3]=t[3]*i,e[4]=t[4]*o,e[5]=t[5]*o,e[6]=t[6]*o,e[7]=t[7]*o,e[8]=t[8]*n,e[9]=t[9]*n,e[10]=t[10]*n,e[11]=t[11]*n,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function Mt(e,t,r){var i=Math.sin(r),o=Math.cos(r),n=t[4],s=t[5],a=t[6],c=t[7],u=t[8],l=t[9],h=t[10],f=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=n*o+u*i,e[5]=s*o+l*i,e[6]=a*o+h*i,e[7]=c*o+f*i,e[8]=u*o-n*i,e[9]=l*o-s*i,e[10]=h*o-a*i,e[11]=f*o-c*i,e}function Vt(e,t,r){var i=Math.sin(r),o=Math.cos(r),n=t[0],s=t[1],a=t[2],c=t[3],u=t[8],l=t[9],h=t[10],f=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=n*o-u*i,e[1]=s*o-l*i,e[2]=a*o-h*i,e[3]=c*o-f*i,e[8]=n*i+u*o,e[9]=s*i+l*o,e[10]=a*i+h*o,e[11]=c*i+f*o,e}function St(e,t,r){var i=Math.sin(r),o=Math.cos(r),n=t[0],s=t[1],a=t[2],c=t[3],u=t[4],l=t[5],h=t[6],f=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=n*o+u*i,e[1]=s*o+l*i,e[2]=a*o+h*i,e[3]=c*o+f*i,e[4]=u*o-n*i,e[5]=l*o-s*i,e[6]=h*o-a*i,e[7]=f*o-c*i,e}function Ut(e,t,r){var i=t[0],o=t[1],n=t[2],s=t[3],a=i+i,c=o+o,u=n+n,l=i*a,h=i*c,f=i*u,p=o*c,v=o*u,g=n*u,d=s*a,M=s*c,L=s*u;return e[0]=1-(p+g),e[1]=h+L,e[2]=f-M,e[3]=0,e[4]=h-L,e[5]=1-(l+g),e[6]=v+d,e[7]=0,e[8]=f+M,e[9]=v-d,e[10]=1-(l+p),e[11]=0,e[12]=r[0],e[13]=r[1],e[14]=r[2],e[15]=1,e}function Nt(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}function Ot(e,t){var r=t[0],i=t[1],o=t[2],n=t[4],s=t[5],a=t[6],c=t[8],u=t[9],l=t[10];return e[0]=Math.hypot(r,i,o),e[1]=Math.hypot(n,s,a),e[2]=Math.hypot(c,u,l),e}function qt(e,t,r,i){var o=t[0],n=t[1],s=t[2],a=t[3],c=o+o,u=n+n,l=s+s,h=o*c,f=o*u,p=o*l,v=n*u,g=n*l,d=s*l,M=a*c,L=a*u,V=a*l,y=i[0],b=i[1],x=i[2];return e[0]=(1-(v+d))*y,e[1]=(f+V)*y,e[2]=(p-L)*y,e[3]=0,e[4]=(f-V)*b,e[5]=(1-(h+d))*b,e[6]=(g+M)*b,e[7]=0,e[8]=(p+L)*x,e[9]=(g-M)*x,e[10]=(1-(h+v))*x,e[11]=0,e[12]=r[0],e[13]=r[1],e[14]=r[2],e[15]=1,e}function $t(e,t){var r=t[0],i=t[1],o=t[2],n=t[3],s=r+r,a=i+i,c=o+o,u=r*s,l=i*s,h=i*a,f=o*s,p=o*a,v=o*c,g=n*s,d=n*a,M=n*c;return e[0]=1-h-v,e[1]=l+M,e[2]=f-d,e[3]=0,e[4]=l-M,e[5]=1-u-v,e[6]=p+g,e[7]=0,e[8]=f+d,e[9]=p-g,e[10]=1-u-h,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function Ht(e,t,r,i,o){var n=1/Math.tan(t/2),s;return e[0]=n/r,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=n,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,o!=null&&o!==1/0?(s=1/(i-o),e[10]=(o+i)*s,e[14]=2*o*i*s):(e[10]=-1,e[14]=-2*i),e}var kt=Ht;function Lt(e,t,r,i){var o,n,s,a,c,u,l,h,f,p,v=t[0],g=t[1],d=t[2],M=i[0],L=i[1],V=i[2],y=r[0],b=r[1],x=r[2];return Math.abs(v-y)<it&&Math.abs(g-b)<it&&Math.abs(d-x)<it?ut(e):(l=v-y,h=g-b,f=d-x,p=1/Math.hypot(l,h,f),l*=p,h*=p,f*=p,o=L*f-V*h,n=V*l-M*f,s=M*h-L*l,p=Math.hypot(o,n,s),p?(p=1/p,o*=p,n*=p,s*=p):(o=0,n=0,s=0),a=h*s-f*n,c=f*o-l*s,u=l*n-h*o,p=Math.hypot(a,c,u),p?(p=1/p,a*=p,c*=p,u*=p):(a=0,c=0,u=0),e[0]=o,e[1]=a,e[2]=l,e[3]=0,e[4]=n,e[5]=c,e[6]=h,e[7]=0,e[8]=s,e[9]=u,e[10]=f,e[11]=0,e[12]=-(o*v+n*g+s*d),e[13]=-(a*v+c*g+u*d),e[14]=-(l*v+h*g+f*d),e[15]=1,e)}function k(){var e=new G(3);return G!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function Xt(e){var t=e[0],r=e[1],i=e[2];return Math.hypot(t,r,i)}function rt(e,t,r){var i=new G(3);return i[0]=e,i[1]=t,i[2]=r,i}function Yt(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e}function jt(e,t){var r=t[0],i=t[1],o=t[2],n=r*r+i*i+o*o;return n>0&&(n=1/Math.sqrt(n)),e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function ft(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function et(e,t,r){var i=t[0],o=t[1],n=t[2],s=r[0],a=r[1],c=r[2];return e[0]=o*c-n*a,e[1]=n*s-i*c,e[2]=i*a-o*s,e}var Wt=Xt;(function(){var e=k();return function(t,r,i,o,n,s){var a,c;for(r||(r=3),i||(i=0),o?c=Math.min(o*r+i,t.length):c=t.length,a=i;a<c;a+=r)e[0]=t[a],e[1]=t[a+1],e[2]=t[a+2],n(e,e,s),t[a]=e[0],t[a+1]=e[1],t[a+2]=e[2];return t}})();function Tt(){var e=new G(4);return G!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0,e[3]=0),e}function Zt(e){var t=new G(4);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t}function F(e,t,r,i){var o=new G(4);return o[0]=e,o[1]=t,o[2]=r,o[3]=i,o}function Pt(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e[3]=t[3]+r[3],e}function zt(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e[3]=t[3]-r[3],e}function Kt(e,t,r){return e[0]=t[0]*r[0],e[1]=t[1]*r[1],e[2]=t[2]*r[2],e[3]=t[3]*r[3],e}function Qt(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e}function Jt(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=-t[3],e}function H(e,t){var r=t[0],i=t[1],o=t[2],n=t[3],s=r*r+i*i+o*o+n*n;return s>0&&(s=1/Math.sqrt(s)),e[0]=r*s,e[1]=i*s,e[2]=o*s,e[3]=n*s,e}function I(e,t,r){var i=t[0],o=t[1],n=t[2],s=t[3];return e[0]=r[0]*i+r[4]*o+r[8]*n+r[12]*s,e[1]=r[1]*i+r[5]*o+r[9]*n+r[13]*s,e[2]=r[2]*i+r[6]*o+r[10]*n+r[14]*s,e[3]=r[3]*i+r[7]*o+r[11]*n+r[15]*s,e}(function(){var e=Tt();return function(t,r,i,o,n,s){var a,c;for(r||(r=4),i||(i=0),o?c=Math.min(o*r+i,t.length):c=t.length,a=i;a<c;a+=r)e[0]=t[a],e[1]=t[a+1],e[2]=t[a+2],e[3]=t[a+3],n(e,e,s),t[a]=e[0],t[a+1]=e[1],t[a+2]=e[2],t[a+3]=e[3];return t}})();function nt(){var e=new G(4);return G!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function te(e,t,r){r=r*.5;var i=Math.sin(r);return e[0]=i*t[0],e[1]=i*t[1],e[2]=i*t[2],e[3]=Math.cos(r),e}function ee(e,t,r){var i=t[0],o=t[1],n=t[2],s=t[3],a=r[0],c=r[1],u=r[2],l=r[3];return e[0]=i*l+s*a+o*u-n*c,e[1]=o*l+s*c+n*a-i*u,e[2]=n*l+s*u+i*c-o*a,e[3]=s*l-i*a-o*c-n*u,e}function re(e,t,r){r*=.5;var i=t[0],o=t[1],n=t[2],s=t[3],a=Math.sin(r),c=Math.cos(r);return e[0]=i*c+s*a,e[1]=o*c+n*a,e[2]=n*c-o*a,e[3]=s*c-i*a,e}function ie(e,t,r){r*=.5;var i=t[0],o=t[1],n=t[2],s=t[3],a=Math.sin(r),c=Math.cos(r);return e[0]=i*c-n*a,e[1]=o*c+s*a,e[2]=n*c+i*a,e[3]=s*c-o*a,e}function oe(e,t,r){r*=.5;var i=t[0],o=t[1],n=t[2],s=t[3],a=Math.sin(r),c=Math.cos(r);return e[0]=i*c+o*a,e[1]=o*c-i*a,e[2]=n*c+s*a,e[3]=s*c-n*a,e}function st(e,t,r,i){var o=t[0],n=t[1],s=t[2],a=t[3],c=r[0],u=r[1],l=r[2],h=r[3],f,p,v,g,d;return p=o*c+n*u+s*l+a*h,p<0&&(p=-p,c=-c,u=-u,l=-l,h=-h),1-p>it?(f=Math.acos(p),v=Math.sin(f),g=Math.sin((1-i)*f)/v,d=Math.sin(i*f)/v):(g=1-i,d=i),e[0]=g*o+d*c,e[1]=g*n+d*u,e[2]=g*s+d*l,e[3]=g*a+d*h,e}function $(e,t){var r=t[0],i=t[1],o=t[2],n=t[3],s=r*r+i*i+o*o+n*n,a=s?1/s:0;return e[0]=-r*a,e[1]=-i*a,e[2]=-o*a,e[3]=n*a,e}function Ct(e,t){var r=t[0]+t[4]+t[8],i;if(r>0)i=Math.sqrt(r+1),e[3]=.5*i,i=.5/i,e[0]=(t[5]-t[7])*i,e[1]=(t[6]-t[2])*i,e[2]=(t[1]-t[3])*i;else{var o=0;t[4]>t[0]&&(o=1),t[8]>t[o*3+o]&&(o=2);var n=(o+1)%3,s=(o+2)%3;i=Math.sqrt(t[o*3+o]-t[n*3+n]-t[s*3+s]+1),e[o]=.5*i,i=.5/i,e[3]=(t[n*3+s]-t[s*3+n])*i,e[n]=(t[n*3+o]+t[o*3+n])*i,e[s]=(t[s*3+o]+t[o*3+s])*i}return e}var at=Zt,ne=F,Ft=H;(function(){var e=k(),t=rt(1,0,0),r=rt(0,1,0);return function(i,o,n){var s=ft(o,n);return s<-.999999?(et(e,t,o),Wt(e)<1e-6&&et(e,r,o),jt(e,e),te(i,e,Math.PI),i):s>.999999?(i[0]=0,i[1]=0,i[2]=0,i[3]=1,i):(et(e,o,n),i[0]=e[0],i[1]=e[1],i[2]=e[2],i[3]=1+s,Ft(i,i))}})();(function(){var e=nt(),t=nt();return function(r,i,o,n,s,a){return st(e,i,s,a),st(t,o,n,a),st(r,e,t,2*a*(1-a)),r}})();(function(){var e=xt();return function(t,r,i,o){return e[0]=i[0],e[3]=i[1],e[6]=i[2],e[1]=o[0],e[4]=o[1],e[7]=o[2],e[2]=-r[0],e[5]=-r[1],e[8]=-r[2],Ft(t,Ct(t,e))}})();const ot=class D{constructor(){C(this,"_coord"),C(this,"scale",t=>{const r=new D;return Qt(r._coord,this._coord,t),r}),C(this,"dot",t=>ft(this.vec3(),t.vec3())),C(this,"add",t=>{const r=new D;return Pt(r._coord,this._coord,t._coord),r}),C(this,"multiply",t=>{const r=new D;return Kt(r._coord,this._coord,t._coord),r}),this._coord=F(0,0,0,0)}static get bufferSize(){return 4*4}static fromValues(t,r,i){const o=new D;return o._coord=F(t,r,i,0),o}static fromVec4(t){const r=new D,i=t[3]!==0?t[3]:1;return r._coord=F(t[0]/i,t[1]/i,t[2]/i,0),r}static fromVec3(t){const r=new D;return r._coord=F(t[0],t[1],t[2],0),r}static fromPoints(t,r){const i=new D;return zt(i._coord,t.vec4(),r.vec4()),i}static fromPoint(t){const r=new D;return r._coord=[...t.triplet,0],r}toString(){return`Vector(${this.x}, ${this.y}, ${this.z})`}map(t){const r=new D;return t.isFrame()?I(r._coord,this._coord,t.inverseMatrix):I(r._coord,this._coord,t.directMatrix),r}unMap(t){const r=new D;return t.isFrame()?I(r._coord,this._coord,t.directMatrix):I(r._coord,this._coord,t.inverseMatrix),r}relative(t){return this.map(t)}absolute(t){return this.unMap(t)}isUnitVector(){return!1}get x(){return this._coord[0]}get y(){return this._coord[1]}get z(){return this._coord[2]}get triplet(){return[this.x,this.y,this.z]}get coordinates(){return[...this._coord.values()]}buffer(){return new Float32Array(this.coordinates)}get length(){const t=this._coord[0],r=this._coord[1],i=this._coord[2];return Math.sqrt(t*t+r*r+i*i)}get lengthSquare(){const t=this._coord[0],r=this._coord[1],i=this._coord[2];return t*t+r*r+i*i}vec3(){return rt(this.x,this.y,this.z)}vec4(){return F(this.x,this.y,this.z,0)}};C(ot,"crossProduct",(e,t)=>{const r=k();return et(r,e.vec3(),t.vec3()),ot.fromVec3(r)}),C(ot,"dot",(e,t)=>ft(e.vec3(),t.vec3()));let P=ot;class m{constructor(){C(this,"_coord"),this._coord=F(0,0,0,1)}static get bufferSize(){return 4*4}static origin(){return new m}static fromValues(t,r,i,o=1){const n=new m;return n._coord=F(t/o,r/o,i/o,1),n}static fromVector(t){const r=new m;return r._coord=F(t.x,t.y,t.z,1),r}static fromVec4(t){const r=new m,i=t[3]!==0?t[3]:1;return r._coord=F(t[0]/i,t[1]/i,t[2]/i,1),r}static fromVec3(t){const r=new m;return r._coord=F(t[0],t[1],t[2],1),r}toString(){return`Point(${this.x}, ${this.y}, ${this.z})`}map(t){const r=new m;return t.isFrame()?I(r._coord,this._coord,t.inverseMatrix):I(r._coord,this._coord,t.directMatrix),r}unMap(t){const r=new m;return t.isFrame()?I(r._coord,this._coord,t.directMatrix):I(r._coord,this._coord,t.inverseMatrix),r}relative(t){return this.map(t)}absolute(t){return this.unMap(t)}static relative(t,r){return t.map(r)}static absolute(t,r){return t.unMap(r)}subtract(t){const r=Tt();return zt(r,this._coord,t._coord),P.fromVec4(r)}scale(t){const r=k();return Yt(r,this.vec3(),t),m.fromVec3(r)}add(t){const r=new m;return Pt(r._coord,this._coord,t.vec4()),r}isPoint(){return!0}get x(){return this._coord[0]}get y(){return this._coord[1]}get z(){return this._coord[2]}get coordinates(){return[...this._coord.values()]}get triplet(){return[this.x,this.y,this.z]}buffer(){return new Float32Array(this.coordinates)}vec3(){return rt(this.x,this.y,this.z)}vec4(){return F(this.x,this.y,this.z,1)}}const ht=class N{constructor(){C(this,"_coord"),this._coord=F(1,1,1,0)}static get bufferSize(){return 4*4}static fromVector(t){const r=new N;return r._coord=F(t.x,t.y,t.z,0),H(r._coord,r._coord),r}fromPoint(t){return N.fromValues(...t.triplet)}static fromValues(t,r,i){const o=F(t,r,i,0);return H(o,o),N.fromVec4(o)}static fromVec4(t){const r=new N,i=t[3]!==0?t[3]:1;return r._coord=F(t[0]/i,t[1]/i,t[2]/i,0),H(r._coord,r._coord),r}static fromVec3(t){const r=new N;return r._coord=F(t[0],t[1],t[2],0),H(r._coord,r._coord),r}toString(){return`UnitVector(${this.x}, ${this.y}, ${this.z})`}map(t){const r=new N;return t.isFrame()?I(r._coord,this._coord,t.inverseMatrix):I(r._coord,this._coord,t.directMatrix),H(r._coord,r._coord),r}unMap(t){const r=new N;return t.isFrame()?I(r._coord,this._coord,t.directMatrix):I(r._coord,this._coord,t.inverseMatrix),H(r._coord,r._coord),r}relative(t){return this.map(t)}absolute(t){return this.unMap(t)}invert(){const t=new N;return Jt(t._coord,this._coord),t}scale(t){return P.fromValues(this.x*t,this.y*t,this.z*t)}isUnitVector(){return!0}get x(){return this._coord[0]}get y(){return this._coord[1]}get z(){return this._coord[2]}get length(){return 1}get coordinates(){return[...this._coord.values()]}get triplet(){return[this.x,this.y,this.z]}buffer(){return new Float32Array(this.coordinates)}vec3(){return rt(this.x,this.y,this.z)}};C(ht,"crossProduct",(e,t)=>{const r=k();return et(r,e.vec3(),t.vec3()),ht.fromVec3(r)});let S=ht;const mt=e=>e.isUnitVector();class _{constructor(){C(this,"_direct"),C(this,"_inverse"),C(this,"_isIdentity",!0),this._direct=O(),this._inverse=O(),T(this._inverse,this._direct)}static get bufferSize(){return 16*4}static world(){return new _}static identity(){return new _}static fromRotation(t){const r=new _;return $t(r._direct,t.quat),T(r._inverse,r._direct),r._isIdentity=!1,r}static fromMat4(t){const r=new _,i=O();return T(i,t),r._direct=U(t),r._inverse=U(i),r._isIdentity=!1,r}static lookAt(t,r,i){const o=new _;return Lt(o._direct,t.vec3(),r.vec3(),i.vec3()),T(o._inverse,o._direct),o._isIdentity=!1,o}static perspective(t,r,i,o){const n=new _;return kt(n._direct,t,r,i,o),T(n._inverse,n._direct),n._isIdentity=!1,n}static invert(t){const r=new _;return r._direct=U(t._inverse),r._inverse=U(t._direct),r._isIdentity=!1,r}static translation(t,r,i){const o=new _;return X(o._direct,o._direct,[t,r,i]),T(o._inverse,o._direct),o._isIdentity=!1,o}static move(t){const r=new _;return X(r._direct,r._direct,t.vec3()),T(r._inverse,r._direct),r._isIdentity=!1,r}static rotationX(t){const r=new _;return Mt(r._direct,r._direct,t),T(r._inverse,r._direct),r._isIdentity=!1,r}static rotationY(t){const r=new _;return Vt(r._direct,r._direct,t),T(r._inverse,r._direct),r._isIdentity=!1,r}static rotationZ(t){const r=new _;return St(r._direct,r._direct,t),T(r._inverse,r._direct),r._isIdentity=!1,r}static scale(t,r,i){const o=new _;return Rt(o._direct,o._direct,[t,r,i]),T(o._inverse,o._direct),o._isIdentity=!1,o}static rotoTranslation(t,r){const i=new _;return Ut(i._direct,t.quat,r.vec3()),T(i._inverse,i._direct),i._isIdentity=!1,i}static fromRotationTranslationScale(t,r,i){const o=new _;return qt(o._direct,t.quat,r.vec3(),i.vec3()),T(o._inverse,o._direct),o._isIdentity=!1,o}isFrame(){return!1}get values(){return this._direct.values()}get inverseValues(){return this._inverse.values()}buffer(){return new Float32Array(this._direct.values())}inverseBuffer(){return new Float32Array(this._inverse.values())}apply(t){return t.map(this)}compose(t){const r=new _,{_direct:i,_inverse:o}=this,{_direct:n,_inverse:s}=t;return lt(r._direct,n,i),lt(r._inverse,o,s),r._isIdentity=!1,r}transpose(){const t=new _;return Et(t._direct,this._direct),T(t._inverse,t._direct),t._isIdentity=!1,t}translation(t,r,i){const o=_.translation(t,r,i);return this.compose(o)}rotationX(t){const r=_.rotationX(t);return this.compose(r)}rotationY(t){const r=_.rotationY(t);return this.compose(r)}rotationZ(t){const r=_.rotationZ(t);return this.compose(r)}scale(t,r,i){const o=_.scale(t,r,i);return this.compose(o)}invert(){const t=new _;return t._direct=U(this._inverse),t._inverse=U(this._direct),t._isIdentity=this._isIdentity,t}get directMatrix(){return this._direct}get inverseMatrix(){return this._inverse}get isIdentity(){return this._isIdentity}get scaleVector(){const t=k();return Ot(t,this._direct),P.fromValues(t[0],t[1],t[2])}get positionVector(){const t=k();return Nt(t,this._direct),P.fromValues(t[0],t[1],t[2])}}const dt=class R{constructor(){C(this,"_direct"),C(this,"_inverse"),this._direct=O(),this._inverse=O(),ut(this._direct),ut(this._inverse)}static bufferSize(){return 16*4}static world(){return new R}static translation(t){const r=new R,i=O();return X(i,i,t.vec3()),r._inverse=i,T(r._direct,r._inverse),r}static rotationX(t,r){const i=new R,o=O();return X(o,o,t.vec3()),Mt(o,o,r),i._direct=o,T(i._inverse,i._direct),i}static rotationY(t,r){const i=new R,o=O();return X(o,o,t.vec3()),Vt(o,o,r),i._direct=o,T(i._inverse,i._direct),i}static rotationZ(t,r){const i=new R,o=O();return X(o,o,t.vec3()),St(o,o,r),i._direct=o,T(i._inverse,i._direct),i}static lookAt(t,r,i){const o=new R;return Lt(o._inverse,t.vec3(),r.vec3(),i.vec3()),T(o._direct,o._inverse),o}isFrame(){return!0}toString(){return`Frame(${this.origin}, ${this.i}, ${this.j}, ${this.k})`}map(t){return this.compose(t)}unMap(t){return this.invert().compose(t)}compose(t){const r=new R,{_direct:i}=this,{_direct:o}=t;return lt(r._direct,o,i),T(r._inverse,r._direct),r}toTransform(){return _.fromMat4(this._inverse)}invert(){const t=new R;return t._direct=U(this._inverse),t._inverse=U(this._direct),t}get directMatrix(){return U(this._direct)}get inverseMatrix(){return U(this._inverse)}get i(){return S.fromValues(this._direct[0],this._direct[1],this._direct[2])}get j(){return S.fromValues(this._direct[4],this._direct[5],this._direct[6])}get k(){return S.fromValues(this._direct[8],this._direct[9],this._direct[10])}get o(){return m.fromValues(this._direct[12],this._direct[13],this._direct[14],this._direct[15])}get origin(){return m.fromValues(this._inverse[12],this._inverse[13],this._inverse[14],this._inverse[15])}relative(t){if(t&&se(t)){const r=this.origin.relative(t),i=this.k.relative(t),o=this.i.relative(t);return R.from2Vectors(r,i,o)}return t.relative(this)}};C(dt,"from2Vectors",(e,t,r)=>{const i=new dt,o=mt(t)?t:S.fromVector(t),n=S.crossProduct(o,mt(r)?r:S.fromVector(r)),s=[...S.crossProduct(n,o).coordinates,...n.coordinates,...o.coordinates,...e.coordinates];return i._direct=Dt(...s),T(i._inverse,i._direct),i});let vt=dt;const se=e=>e&&e.isFrame!==void 0?e.isFrame():!1;class E{constructor(){C(this,"_direct"),C(this,"_inverse"),this._direct=nt(),this._inverse=nt()}static identity(){return new E}static fromValues(t,r,i,o){const n=new E;return n._direct=ne(t,r,i,o),$(n._inverse,n._direct),n}static fromQuat(t){const r=new E;return r._direct=at(t),$(r._inverse,r._direct),r}static fromTransform(t){const r=xt();It(r,t.directMatrix);const i=new E;return i._direct=Ct(i._direct,r),$(i._inverse,i._direct),i}static rotationX(t){const r=new E;return re(r._direct,r._direct,t),$(r._inverse,r._direct),r}static rotationY(t){const r=new E;return ie(r._direct,r._direct,t),$(r._inverse,r._direct),r}static rotationZ(t){const r=new E;return oe(r._direct,r._direct,t),$(r._inverse,r._direct),r}inverse(){const t=new E;return t._direct=at(this._inverse),t._inverse=at(this._direct),t}compose(t){const r=new E;return ee(r._direct,this._direct,t._direct),$(r._inverse,r._direct),r}get quat(){return this._direct}}var ae=Object.defineProperty,ce=(e,t,r)=>t in e?ae(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,w=(e,t,r)=>(ce(e,typeof t!="symbol"?t+"":t,r),r);const gt=()=>{let e=0,t=performance.now(),r=0;const i=[];return console.log("Init FPS",t),{getFPS:()=>i.reduce((o,n)=>o+n,0)/i.length,measureFPS:()=>(e=performance.now()-t,e<=1?i[r]:(r=(r+1)%10,i[r]=1e3/e,t=performance.now(),e)),getLastTimeSpan:()=>e}},ue=async({context:e,device:t,format:r},i)=>{e.configure({device:t,format:r,alphaMode:"opaque"});const o=t.createShaderModule({code:i});return(await o.getCompilationInfo()).messages.forEach(n=>{let s=n.message;n.lineNum&&(s=`Line ${n.lineNum}:${n.linePos} - "${i.substr(n.offset,n.length+40)}"
`+n.message),console.error("WGSL error: ",s)}),o},le=e=>{const t=3*_.bufferSize+8+4*(2*P.bufferSize)+4*(P.bufferSize+m.bufferSize),r=4,i=r*(2*P.bufferSize)+r*(P.bufferSize+m.bufferSize)+4*4,o=e.device.createBuffer({label:"TransBuffer",size:t+t%16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),n=e.device.createBuffer({label:"LightBuffer",size:i+i%16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),s=[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}],a=e.device.createBindGroupLayout({label:"transformations",entries:s}),c=[{binding:0,resource:{buffer:o}},{binding:1,resource:{buffer:n}}],u=e.device.createBindGroup({label:"SceneData",layout:a,entries:c});return[a,u,[o,n]]},he=e=>{const t=2*_.bufferSize,r=e.device.createBuffer({label:"TransBuffer",size:t+t%16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),i=[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}],o=e.device.createBindGroupLayout({label:"modelTransf",entries:i}),n=[{binding:0,resource:{buffer:r}}],s=e.device.createBindGroup({label:"SceneData",layout:o,entries:n});return[o,s,[r]]},de=e=>{const t=e.device.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),r=[{binding:0,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}],i=e.device.createBindGroupLayout({label:"color",entries:r}),o=[{binding:0,resource:{buffer:t}}],n=e.device.createBindGroup({label:"color",layout:i,entries:o});return[i,n,[t]]},fe=(e,t)=>{const r=[{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{}}],i=e.device.createBindGroupLayout({label:"texture",entries:r}),o=[{binding:0,resource:t.view},{binding:1,resource:t.sampler}],n=e.device.createBindGroup({label:"texture",layout:i,entries:o});return[i,n]},pe=(e,t)=>{const{device:r}=e,[i,o,n]=le(e),[s,a,c]=de(e),[u,l,h]=he(e),[f,p]=t?fe(e,t):[void 0,void 0],v=f?[i,s,u,f]:[i,s,u],g=[o,a,l,p],d=[n,c,h];return[r.createPipelineLayout({bindGroupLayouts:v}),g,d]},_t=(e,t,r)=>{const{device:i,format:o}=e,n=r.map(([s,a])=>{const[c,u,l]=pe(e,a),h={label:s.label,layout:c,multisample:{count:1},vertex:{module:t,entryPoint:s.vertexShader,buffers:[s.bufferLayout]},fragment:{module:t,entryPoint:s.fragmentShader,targets:[{format:o,blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"}}}]},primitive:{topology:s.primitives,cullMode:s.cullMode},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"}},f=i.createRenderPipeline(h),p={...h,label:`${s.label}-alt`,primitive:{topology:"line-list",cullMode:"none"}},v=i.createRenderPipeline(p);return[s.id,{id:s.id,type:s.label,pipeline:f,altPipeline:v,geoRenderable:s,uniformBuffers:l,bindGroups:u}]});return new Map(n)},me=(e,t)=>{let r="none",i=[0,0],o=[0,0],n=[0,0];e.addEventListener("contextmenu",s=>{s.preventDefault()}),e.addEventListener("wheel",s=>{s.ctrlKey?t.tilt(s.deltaY):t.zoom(s.deltaY)}),e.addEventListener("pointerdown",s=>{e.setPointerCapture(s.pointerId),i=[s.offsetX,s.offsetY],o=[0,0],n=i,r=`${s.ctrlKey?"ctrl-":""}mouse-${s.button}`,t.move(r,{origin:i,direction:o},n)}),e.addEventListener("pointermove",s=>{if(r==="none")return;const a=[s.offsetX,s.offsetY];o=[a[0]-n[0],a[1]-n[1]],n=a,t.move(r,{origin:i,direction:o},n)}),e.addEventListener("pointerup",s=>{e.releasePointerCapture(s.pointerId);const a=[s.offsetX,s.offsetY];o=[a[0]-i[0],a[1]-i[1]],o[0]<=.9&&o[1]<=.9&&t.click("none",a),t.move("none",{origin:i,direction:o},a),r="none"})},ve=(e,t,r=GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST)=>{const i=e.createBuffer({size:t.byteLength,usage:r,mappedAtCreation:!0});return new Float32Array(i.getMappedRange()).set(t),i.unmap(),i},yt=e=>{const{device:t,canvas:r}=e,i=t.createTexture({size:{width:r.width,height:r.height,depthOrArrayLayers:1},sampleCount:1,format:e.format,usage:GPUTextureUsage.RENDER_ATTACHMENT}),o=t.createTexture({label:"DepthTexture",sampleCount:1,size:[r.width,r.height,1],format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT}),n=Le(window.getComputedStyle(r).backgroundColor);return{colorAttachments:[{view:i.createView(),clearValue:n,loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:o.createView(),depthClearValue:1,depthStoreOp:"store",depthLoadOp:"clear"}}},ge=async e=>{const t=await navigator.gpu.requestAdapter({powerPreference:"high-performance"});if(!t)throw new Error("WebGPU:adapter is NOT available!");const r=await t.requestAdapterInfo();console.log("WebGPU:adapter info",r),console.log("WebGPU:adapter is fallback:",t.isFallbackAdapter);const i=await t.requestDevice();if(!i)throw new Error("WebGPU:device is NOT available!");const o=e.getContext("webgpu");if(!o)throw new Error("WebGPU:context from instantiated Canvas not available!");const n=navigator.gpu.getPreferredCanvasFormat();return o.configure({device:i,format:n,usage:GPUTextureUsage.RENDER_ATTACHMENT,alphaMode:"opaque"}),{context:o,device:i,canvas:e,format:n}},_e=e=>typeof e=="string",ye=(e,[t,r],i)=>({view:i&&i.view?i.view(e.view):_.lookAt(m.fromValues(-5,-5,-5),m.fromValues(0,0,0),S.fromValues(0,0,1)),projection:i&&i.projection?i.projection(e.projection):_.perspective(Math.PI/5,t/r,.1,100)}),we=(e,t)=>Math.log(e)/Math.log(t),be=`const MAX_DIR_LIGHTS: u32 = 4;
const MAX_POINT_LIGHTS: u32 = 4;

struct DirectionalLight {
  dir: vec4<f32>,
  col: vec4<f32>,
};

struct PointLight {
  pos: vec4<f32>,  // Position of the light
  col: vec4<f32>,  // Color of the light
};

struct SceneData {
  view: mat4x4<f32>,
  invertView: mat4x4<f32>,
  projection: mat4x4<f32>,
};

struct ModelData {
  model: mat4x4<f32>,
  modelInverseTranspose: mat4x4<f32>,
};

struct SceneLights {
  dirLights: array<DirectionalLight, MAX_DIR_LIGHTS>,
  pointLights: array<PointLight, MAX_POINT_LIGHTS>,
  ambient: vec4<f32>,
};

struct ObjectData {
  model: mat4x4<f32>,
};

struct TextFragment {
  @builtin(position) position: vec4<f32>,
  @location(0) texCoord: vec2<f32>,
  @location(1) normal: vec3<f32>,
  @location(2) pos: vec3<f32>,
  @location(3) eye: vec3<f32>,
};

struct ColorFragment {
  @builtin(position) position: vec4<f32>,
  @location(0) normal: vec3<f32>,
  @location(1) pos: vec3<f32>,
  @location(2) eye: vec3<f32>,
};

struct ColorLineFragment {
  @builtin(position) position: vec4<f32>,
  @location(0) viewZ: f32,
  @location(1) targetZ: f32,
};

struct ColorData {
    color: vec4<f32>,
};


@group(0) @binding(0) var<uniform> sceneData: SceneData;
@group(0) @binding(1) var<uniform> sceneLights: SceneLights;
@group(1) @binding(0) var<uniform> myColor: ColorData;
@group(2) @binding(0) var<uniform> myModel: ModelData;
@group(3) @binding(0) var myTexture: texture_2d<f32>;
@group(3) @binding(1) var mySampler: sampler;

fn computeDiffuseColor(
    eye: vec3<f32>,
    pos: vec3<f32>,
    normal: vec3<f32>,
    sceneLights: SceneLights) -> vec3<f32> {
  let shininess: f32 = 32.0;
  var diffuse: vec3<f32> = sceneLights.ambient.rgb;
  for (var i: u32 = 0; i < MAX_DIR_LIGHTS; i = i + 1) {
    if (sceneLights.dirLights[i].col.a != 0.0) {
      let lightDir: vec3<f32> = normalize(sceneLights.dirLights[i].dir.xyz); //
      let lightColor: vec3<f32> = sceneLights.dirLights[i].col.rgb;
      var NdotL: f32 = pow(max(dot(normal, lightDir), 0), 2);
      diffuse = diffuse + (NdotL * lightColor);
    }
  }
  for (var i: u32 = 0; i < MAX_POINT_LIGHTS; i = i + 1) {
    if (sceneLights.pointLights[i].col.a != 0.0) {
      let dir = sceneLights.pointLights[i].pos.xyz - pos; //  - pos.xyz;
      let attenuation = 1.0 - clamp(pow( length(dir)/20, 2.0), 0.0, 1.0 );

      let lightDir: vec3<f32> = normalize(dir);
      let lightColor: vec3<f32> = sceneLights.pointLights[i].col.rgb;
      var NdotL: f32 = pow(max(dot(normal, lightDir), 0), 2);
      let diffuseColor = NdotL * lightColor;

      // Specular
      let V = normalize(pos - eye);
      let R = normalize(reflect(lightDir, normal));
      let specularIntensity = pow(max(dot(V, R), 0.0), shininess);
      let specularColor = specularIntensity * lightColor;

      diffuse = diffuse + (diffuseColor+ specularColor) * attenuation;
    }
  }
  return clamp(diffuse, vec3<f32>(0.0, 0.0, 0.0), vec3<f32>(1.0, 1.0, 1.0));
}


// ----------------------------------------------------------------------------------------------- Texture Shaders

@vertex
fn vertexTextureShader(
    @location(0) vertexPosition: vec3<f32>,
    @location(1) vertexTexCoord: vec2<f32>,
    @location(2) vertexNormal: vec3<f32>) -> TextFragment {
  var output: TextFragment;
  var vertex = myModel.model * vec4<f32>(vertexPosition, 1.0);
  output.position = sceneData.projection * sceneData.view * vertex;
  output.texCoord = vec2<f32>(vertexTexCoord);
  output.normal = (myModel.modelInverseTranspose * vec4<f32>(vertexNormal, 0.0)).xyz;
  output.pos = vertex.xyz;
  output.eye = sceneData.invertView[3].xyz;

  return output;
}

@fragment
fn fragmentTextureShader(in: TextFragment) -> @location(0) vec4<f32> {
  let diffuse: vec3<f32> = computeDiffuseColor( in.eye, in.pos, normalize(in.normal), sceneLights );
  let texColor: vec4<f32> = textureSample(myTexture, mySampler, in.texCoord);

  return vec4<f32>(texColor.rgb * diffuse, 1.0);
}

// ----------------------------------------------------------------------------------------------- Color Shaders

@vertex
fn vertexColorShader(
    @location(0) vertexPosition: vec3<f32>,
    @location(1) vertexNormal: vec3<f32>) -> ColorFragment {
  var output: ColorFragment;
  var vertex = myModel.model * vec4<f32>(vertexPosition, 1.0);
  output.normal = (myModel.modelInverseTranspose * vec4<f32>(vertexNormal, 0.0)).xyz;
  output.position = sceneData.projection * sceneData.view * vertex;
  output.pos = vertex.xyz;
  output.eye = sceneData.invertView[3].xyz;
  // Transform the light direction in camera coordinat with the inverse of the view matrix to view space
  // output.light =  normalize(sceneData.invertView * sceneData.light.dir);
  // output.lightCol = sceneData.light.col;
  return output;
}

@fragment
fn fragmentColorShader(in: ColorFragment) -> @location(0) vec4<f32> {
  let diffuse: vec3<f32> = computeDiffuseColor( in.eye, in.pos, normalize(in.normal), sceneLights );
  return vec4<f32>(myColor.color.rgb * diffuse.rgb, myColor.color.a);
}


@vertex
fn vertexLineShader(
    @location(0) vertexPosition: vec3<f32>) -> ColorLineFragment {
  var output: ColorLineFragment;
  var vertex = myModel.model * vec4<f32>(vertexPosition, 1.0);

  let eye  = vec4<f32>(sceneData.invertView[3].xyz, 1.0);

  let eyeInViewSpace = sceneData.view * eye;
  let positionInViewSpace = sceneData.view * vertex;
  let bias = 0.002 * positionInViewSpace.z;
  let biasedPositionInViewSpace = positionInViewSpace - vec4<f32>(0.0, 0.0, bias, 0.0);
  output.viewZ = -biasedPositionInViewSpace.z;
  output.targetZ = eyeInViewSpace.z;
  output.position = sceneData.projection * biasedPositionInViewSpace;
  return output;
}


@fragment
fn fragmentLineShader(in: ColorLineFragment) -> @location(0) vec4<f32> {

  let att: f32 =  clamp(in.viewZ / 300, 0.0, 1.0);
  let a: f32 = myColor.color.a - (myColor.color.a * att);

  return vec4<f32>(myColor.color.rgb,a);
  // return vec4<f32>(myColor.color.rgb, a);
}
`,xe="",Me=e=>{const{canvas:t,context:r,device:i}=e;let[o,n]=[t.width,t.height];return new ResizeObserver(s=>{const{width:a,height:c}=s[0].contentRect;[o,n]=[Math.round(a),Math.round(c)]}).observe(t.parentElement),s=>{if(o===t.width&&n===t.height){const h=r.getCurrentTexture(),f=s.colorAttachments;return f[0].view=h.createView({label:"ColorView"}),s}t.width=o,t.height=n;const a=i.createTexture({label:"DepthTexture",sampleCount:1,size:[o,n,1],format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT}),c=i.createTexture({label:"ColorTexture",size:{width:o,height:n,depthOrArrayLayers:1},sampleCount:1,format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT}),u=s.colorAttachments;u[0].view=c.createView({label:"ColorView"});const l=s.depthStencilAttachment;return l.view=a.createView({label:"DepthView"}),s}};class pt{constructor(t,r,i,o){w(this,"canvas"),w(this,"context"),w(this,"device"),w(this,"format"),w(this,"_handleOnRender"),w(this,"_vertexCount",0),w(this,"_activeRenderLoop",!1),w(this,"_pipelineMode","default"),w(this,"_shaderModule"),w(this,"_pipelines",new Map),w(this,"_transformations",{projection:_.identity(),view:_.identity()}),w(this,"_renderPassDescription"),w(this,"_cameraTransHandler"),w(this,"_lightsHandler"),w(this,"_modelHandlers",{}),w(this,"_fps",gt()),w(this,"_rebuildViewTexture"),w(this,"_ambientLight",[.1,.1,.1,1]),w(this,"_dirLights",[{dir:S.fromValues(-1,-1,1),col:[.3,.3,.3,1]},{dir:S.fromValues(1,1,1),col:[.4,.3,.3,1]},{dir:S.fromValues(1,0,0),col:[.5,.5,.5,0]},{dir:S.fromValues(-1,-1,-1),col:[.3,.3,.3,0]}]),w(this,"_pointLights",[{pos:m.fromValues(-12,12,8),col:[.5,.5,.2,1]},{pos:m.fromValues(12,12,8),col:[.4,.2,.2,1]},{pos:m.fromValues(-12,-12,8),col:[.2,.2,.5,1]},{pos:m.fromValues(12,-12,8),col:[.5,.1,.5,1]}]),w(this,"render",()=>{const{device:n}=this;this._vertexCount=0,this._handleOnRender&&this._handleOnRender(this);let s=this._renderPassDescription??yt(this);this._rebuildViewTexture&&(this._renderPassDescription=this._rebuildViewTexture(s));const a=n.createCommandEncoder(),c=a.beginRenderPass(s),u=this._fps.getLastTimeSpan();this.updateLights(u),this.pipelines.filter(({geoRenderable:l})=>l.color[3]===1).forEach((l,h)=>{this.renderPipeline(l,h,c,u)}),this.pipelines.filter(({geoRenderable:l})=>l.color[3]<1).forEach((l,h)=>{this.renderPipeline(l,h,c,u)}),c.end(),n.queue.submit([a.finish()])}),this.canvas=t,this.context=r,this.device=i,this.format=o,this._rebuildViewTexture=Me(this),this.device.lost.then(()=>{console.log("WebGPU:device lost")})}get vertexCount(){return this._vertexCount}get fps(){return this._fps.getFPS()}get dirLights(){return this._dirLights}get pontLights(){return this._pointLights}setAmbientLight(t){this._ambientLight=t}setLight(t,r,i){switch(t){case"directional":this._dirLights[r]=i;break;case"point":this._pointLights[r]=i;break}}static async build(t){return ge(t).then(({canvas:r,context:i,device:o,format:n})=>new pt(r,i,o,n))}setPipelineMode(t){this._pipelineMode=t}get pipelines(){return[...this._pipelines.values()]}getScene(){return[...this._pipelines.values()].map(({geoRenderable:t})=>[t,void 0])}async setupShaders(t){if(this._shaderModule)return this;let r;if(_e(t))switch(t){case"standard-3d":r=be;break;case"standard-2d":default:r=xe;break}else r=t.source;return this._shaderModule=await ue(this,r),this}setScene(t){if(!this._shaderModule)throw new Error("WebGPU:shader module is NOT available!");t.forEach(([r,i])=>{r.buildGpuBuffer(this)}),this._pipelines=_t(this,this._shaderModule,t),this._renderPassDescription=yt(this)}addToScene(t){if(!this._shaderModule)throw new Error("WebGPU:shader module is NOT available!");t.forEach(([r,i])=>{r.buildGpuBuffer(this)}),_t(this,this._shaderModule,t).forEach((r,i)=>{this._pipelines.set(i,r)})}removeFromScene(t){return this._pipelines.delete(t)}clearScene(){this._pipelines.clear()}captureMouseMotion(t){me(this.canvas,{move:(t==null?void 0:t.move)??((r,i,o)=>{}),click:(t==null?void 0:t.click)??((r,i)=>{}),zoom:(t==null?void 0:t.zoom)??(r=>{}),tilt:(t==null?void 0:t.tilt)??(r=>{})})}sceneIntoBuffer(t){const{device:r}=this,{projection:i,view:o}=this._transformations,n=o.invert();let s=0;r.queue.writeBuffer(t[0],s,o.buffer()),s+=_.bufferSize,r.queue.writeBuffer(t[0],s,n.buffer()),s+=_.bufferSize,r.queue.writeBuffer(t[0],s,i.buffer()),s+=_.bufferSize;let a=0;const c=new Float32Array(this._dirLights.flatMap(({dir:h,col:f})=>[...h.coordinates,...f]));r.queue.writeBuffer(t[1],a,c),a+=c.byteLength;const u=new Float32Array(this._pointLights.flatMap(({pos:h,col:f})=>[...h.coordinates,...f]));r.queue.writeBuffer(t[1],a,u),a+=u.byteLength;const l=new Float32Array(this._ambientLight);r.queue.writeBuffer(t[1],a,l)}updateLights(t){if(!this._lightsHandler)return;const{dirLights:r,posLights:i}=this._lightsHandler;r&&r(t,this._dirLights),i&&i(t,this._pointLights)}onRender(t){this._handleOnRender=t}renderPipeline(t,r,i,o){const{pipeline:n,altPipeline:s,uniformBuffers:a,bindGroups:c,geoRenderable:u}=t,{device:l}=this;r===0&&(this.sceneIntoBuffer(a[0]),i.setBindGroup(0,c[0]));const h=this._pipelineMode==="default"?n:s;i.setPipeline(h);const f=new Float32Array(u.color);l.queue.writeBuffer(a[1][0],0,f),i.setBindGroup(1,c[1]),this._modelHandlers[u.id]&&u.transform(o,this._modelHandlers[u.id]),l.queue.writeBuffer(a[2][0],0,u.transformationData),i.setBindGroup(2,c[2]),c[3]&&i.setBindGroup(3,c[3]),u.buffers.forEach((p,v)=>{const g=u.getVertexCountPerStrip(v);this._vertexCount+=g,i.setVertexBuffer(0,p),i.draw(g)})}renderLoop(){const{width:t,height:r}=this.canvas;this._transformations=ye(this._transformations,[t,r],this._cameraTransHandler),this.render(),this._fps.measureFPS(),this._activeRenderLoop&&requestAnimationFrame(this.renderLoop.bind(this))}beginRenderLoop(t){this._fps=gt(),this._cameraTransHandler=t==null?void 0:t.camera,this._lightsHandler=t==null?void 0:t.lights,this._modelHandlers=(t==null?void 0:t.models)??{},this._activeRenderLoop=!0,this.renderLoop()}endRenderLoop(){this._activeRenderLoop=!1}}let tt=new Map;const Ve=async e=>{var t,r;if(!navigator.gpu)return Promise.reject(new Error("WebGPU is not supported in this browser!"));const i=(t=tt.get(e.id))==null?void 0:t.gpu;if(i)return Promise.resolve(i);if((r=tt.get(e.id))!=null&&r.initializing)return new Promise((n,s)=>{setTimeout(()=>{var a;const c=(a=tt.get(e.id))==null?void 0:a.gpu;if(c)return console.warn("WebGPU connection already initialized. Reusing previous connection."),n(c);s(new Error("WebGPU already initialization is taking too long!"))},100)});tt.set(e.id,{initializing:!0});const o=await pt.build(e);return tt.set(e.id,{initializing:!1,gpu:o}),Promise.resolve(o)},Se=(e,t)=>{const{device:r}=e,i="rgba8unorm",o={size:[t.width,t.height,1],format:i,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT},n=r.createTexture(o);r.queue.copyExternalImageToTexture({source:t},{texture:n},[t.width,t.height]);const s=n.createView(),a={addressModeU:"repeat",addressModeV:"repeat",magFilter:"linear",minFilter:"nearest",mipmapFilter:"nearest",maxAnisotropy:1},c=r.createSampler(a);return{texture:n,view:s,sampler:c}},Le=e=>{let t=[];const r=/rgba?\(([^)]+)\)/.exec(e);if(r&&r[1]&&(t=r[1].split(",").map(a=>parseFloat(a.trim()))),t.length<3)throw new Error("Invalid RGB/RGBA format");const i=t[0]/255,o=t[1]/255,n=t[2]/255,s=t.length===4?t[3]:1;return{r:i,g:o,b:n,a:s}},q=4;class Gt{constructor(t,r,i=[1,1,1,1]){w(this,"_body",null),w(this,"_id"),w(this,"_bufferData",null),w(this,"_vertices",[]),w(this,"_colors",[]),w(this,"_normals",[]),w(this,"_textures",[]),w(this,"_color",[1,1,1,1]),w(this,"_hasTextures",!1),w(this,"_vertexByteSize",0),w(this,"_buffers",[]),w(this,"_bufferLayout",null),w(this,"_topology","triangle-list"),w(this,"_cullMode","back"),w(this,"_transformation",{rotation:E.identity(),scale:P.fromValues(1,1,1),translation:P.fromValues(0,0,0)}),this._id=t,this._topology=r,this._vertexByteSize=3*4,this._color=i}get id(){return this._id}get label(){return this._topology}get translationVector(){return this._transformation.translation}get orientationRotation(){return this._transformation.rotation}get scaleVector(){return this._transformation.scale}get hasTextures(){return this._hasTextures}get vertexShader(){return this._topology==="triangle-strip"||this._topology==="triangle-list"?this.hasTextures?"vertexTextureShader":"vertexColorShader":"vertexLineShader"}get fragmentShader(){return this._topology==="triangle-strip"||this._topology==="triangle-list"?this.hasTextures?"fragmentTextureShader":"fragmentColorShader":"fragmentLineShader"}get color(){return this._color}get primitives(){return this._topology}get cullMode(){return this._topology==="triangle-strip"||this._topology==="triangle-list"?this._cullMode:"none"}get vertexCount(){return this._vertices.reduce((t,r)=>t+r.length/3,0)}get body(){return this._body}get transformation(){return _.fromRotationTranslationScale(this._transformation.rotation,this._transformation.translation,this._transformation.scale)}get transformationData(){const t=this.transformation;return new Float32Array([...t.values,...t.transpose().invert().values])}setBody(t){return this._body=t,this}scale(t){return this._transformation.scale=this._transformation.scale.multiply(t),this}translate(t){return this._transformation.translation=this._transformation.translation.add(t),this}rotate(t){return this._transformation.rotation=this._transformation.rotation.compose(t),this}rotoTranslate(t,r){const i=this._transformation;return i.rotation=t,i.translation=r,this}transform(t,r){return this._transformation=r(t,this._transformation),this}getVertexCountPerStrip(t){return this._vertices[t].length/3}get vertexByteSize(){return this._vertexByteSize}getByteSizePerStrip(t=0){return this._vertices[t].length*q+(this._colors.length>0?this._colors[t].length*q:0)+(this._normals.length>0?this._normals[t].length*q:0)+(this._textures.length>0?this._textures[t].length*q:0)}setCullMode(t){return this._cullMode=t,this}addVertices(t){this._vertices.push(t)}getBufferData(){return this._bufferData!==null?this._bufferData:(this._bufferData=this._vertices.map((t,r)=>{const i=[];for(let o=0,n=0,s=0,a=0;o<t.length;o+=3,n+=4,s+=3,a+=2){const c=[t[o+0],t[o+1],t[o+2]];this._colors.length>r&&(c.push(this._colors[r][n+0]),c.push(this._colors[r][n+1]),c.push(this._colors[r][n+2]),c.push(this._colors[r][n+3])),this._textures.length>r&&(c.push(this._textures[r][a+0]),c.push(this._textures[r][a+1])),this._normals.length>r&&(c.push(this._normals[r][s+0]),c.push(this._normals[r][s+1]),c.push(this._normals[r][s+2])),i.push(...c)}return new Float32Array(i)}),this._bufferData)}get layouts(){let t=0,r=0;const i=[{shaderLocation:t,offset:0,format:"float32x3"}];return t+=1,r+=3*q,this._colors.length>0&&(i.push({shaderLocation:t,offset:r,format:"float32x4"}),t+=1,r+=4*q),this._textures.length>0&&(i.push({shaderLocation:t,offset:r,format:"float32x2"}),t+=1,r+=2*q),this._normals.length>0&&(i.push({shaderLocation:t,offset:r,format:"float32x3"}),t+=1,r+=3*q),i}get buffers(){return this._buffers}get bufferLayout(){if(this._bufferLayout===null)throw new Error("TriangleData: Buffer layout is not available! - Did you call buildGpuBuffer() ?");return this._bufferLayout}buildGpuBuffer(t){this._buffers=this.getBufferData().map(r=>ve(t.device,r)),this._bufferLayout={arrayStride:this.vertexByteSize,attributes:this.layouts}}addColors(t){this._colors.length===0&&(this._vertexByteSize+=4*4),this._colors.push(t)}addNormals(t){var r;this._normals.length===0&&(this._vertexByteSize+=3*4),(r=this._normals)==null||r.push(t)}addTextures(t){this._textures.length===0&&(this._vertexByteSize+=2*4,this._hasTextures=!0),this._textures.push(t)}}const wt=(e,t)=>{const r=m.fromValues(e[t+0],e[t+1],e[t+2]),i=m.fromValues(e[t+3],e[t+4],e[t+5]),o=m.fromValues(e[t+6],e[t+7],e[t+8]),n=P.fromPoints(i,r),s=P.fromPoints(i,o);return S.crossProduct(s,n)},Te=(e,t)=>{const r=m.fromValues(e[t-6],e[t-5],e[t-4]),i=m.fromValues(e[t-3],e[t-2],e[t-1]),o=m.fromValues(e[t+0],e[t+1],e[t+2]),n=P.fromPoints(i,r),s=P.fromPoints(i,o);return S.crossProduct(s,n)},Pe=(e,t)=>{const r=[],i=e==="triangle-list"?9:3;if(e==="triangle-strip"){let o=wt(t,0);r.push(...o.triplet),r.push(...o.triplet);for(let n=3;n<t.length;n+=i)Te(t,n),r.push(...o.triplet)}else for(let o=0;o<t.length;o+=i){const n=wt(t,o);r.push(...n.triplet),r.push(...n.triplet),r.push(...n.triplet)}return r},ze=(e,t)=>{const{color:r,id:i}=t,o=[m.fromValues(.5,-.5,.5).map(e),m.fromValues(-.5,-.5,.5).map(e),m.fromValues(-.5,-.5,-.5).map(e),m.fromValues(.5,-.5,-.5).map(e),m.fromValues(.5,-.5,.5).map(e),m.fromValues(-.5,-.5,-.5).map(e),m.fromValues(.5,.5,.5).map(e),m.fromValues(.5,-.5,.5).map(e),m.fromValues(.5,-.5,-.5).map(e),m.fromValues(.5,.5,-.5).map(e),m.fromValues(.5,.5,.5).map(e),m.fromValues(.5,-.5,-.5).map(e),m.fromValues(-.5,.5,.5).map(e),m.fromValues(.5,.5,.5).map(e),m.fromValues(.5,.5,-.5).map(e),m.fromValues(-.5,.5,-.5).map(e),m.fromValues(-.5,.5,.5).map(e),m.fromValues(.5,.5,-.5).map(e),m.fromValues(-.5,-.5,.5).map(e),m.fromValues(-.5,.5,.5).map(e),m.fromValues(-.5,.5,-.5).map(e),m.fromValues(-.5,-.5,-.5).map(e),m.fromValues(-.5,-.5,.5).map(e),m.fromValues(-.5,.5,-.5).map(e),m.fromValues(.5,.5,.5).map(e),m.fromValues(-.5,.5,.5).map(e),m.fromValues(-.5,-.5,.5).map(e),m.fromValues(-.5,-.5,.5).map(e),m.fromValues(.5,-.5,.5).map(e),m.fromValues(.5,.5,.5).map(e),m.fromValues(.5,-.5,-.5).map(e),m.fromValues(-.5,-.5,-.5).map(e),m.fromValues(-.5,.5,-.5).map(e),m.fromValues(.5,.5,-.5).map(e),m.fromValues(.5,-.5,-.5).map(e),m.fromValues(-.5,.5,-.5).map(e)].flatMap(a=>a.triplet),n=new Gt(i,"triangle-list",r);n.addVertices(new Float32Array(o)),r||n.addTextures(new Float32Array([0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,0,0,0,1,1,0]));const s=Pe("triangle-list",o);return n.addNormals(new Float32Array(s)),n},Ce=()=>ze,A=.5257311121191336,B=.8506508083520399;S.fromValues(-A,0,B),S.fromValues(A,0,B),S.fromValues(-A,0,-B),S.fromValues(A,0,-B),S.fromValues(0,B,A),S.fromValues(0,B,-A),S.fromValues(0,-B,A),S.fromValues(0,-B,-A),S.fromValues(B,A,0),S.fromValues(-B,A,0),S.fromValues(B,-A,0),S.fromValues(-B,-A,0);const Fe=(e,t)=>{const{color:r,steps:i,id:o}=t,n=e.scaleVector,s=Math.max(n.x,n.y),a=Math.pow(i,Math.floor(we(s,i)))/i,c=Math.floor(n.x/a),u=Math.floor(n.y/a),l=1/c,h=1/u,f=[];for(let v=0;v<c+1;v++){const g=m.fromValues(-.5+l*v,-.5,0).map(e),d=m.fromValues(-.5+l*v,.5,0).map(e);f.push(g,d)}for(let v=0;v<u+1;v++){const g=m.fromValues(-.5,-.5+h*v,0).map(e),d=m.fromValues(.5,-.5+h*v,0).map(e);f.push(g,d)}const p=new Gt(o,"line-list",r);return p.addVertices(new Float32Array(f.flatMap(v=>v.triplet))),p},Ge=()=>Fe,Ae=(e,t=[10,10,10])=>{let r=m.fromValues(0,0,0),i=m.fromValues(...t),o=i.x===0&&i.y===0?S.fromValues(0,1,0):S.fromValues(0,0,1),n=[0,0],s=[0,0],a=0,c=0,u=Math.PI/5,l=P.fromPoints(i,r).lengthSquare,h=vt.lookAt(i,r,o),f=!1;return[{move:(p,v,g)=>{let d=Math.min(e.canvas.width,e.canvas.height),M=1/d*6,L=u/d*2;switch(p){case"mouse-0":n=[v.direction[0]*M,v.direction[1]*M],f=!0;break;case"mouse-1":s=[-v.direction[0]*L,v.direction[1]*L];break;case"mouse-2":u+=v.direction[1]*L;break;case"none":f=!1;break}},zoom:p=>{a=p*.001},tilt:p=>{c=p*5e-4,f=!1}},{view:p=>{if(!p||p!=null&&p.isIdentity)return _.lookAt(i,r,o);const v=P.fromPoints(i,r).scale(1-a);v.length>1.2&&(i=r.add(v));const g=P.fromPoints(r,i),d=_.move(g).apply(h),M=[Math.tan(s[0])*l,Math.tan(s[1])*l],L=P.fromValues(M[0],M[1],0).absolute(d),V=d.relative(i);let y=d.relative(o);y=_.rotationZ(c).apply(y);const b=_.rotationX(-n[1]).compose(_.rotationY(-n[0]));i=b.apply(V).absolute(d),o=b.apply(y).absolute(d);const x=_.move(L);return r=x.apply(r),i=x.apply(i),h=vt.lookAt(i,r,o),f||(n=[n[0]*.95,n[1]*.95],c*=.9,a*=.9,Math.abs(n[0])<.001&&Math.abs(n[1])<.001&&Math.abs(c)<.001&&Math.abs(a)<.001&&(n=[0,0],c=0,a=0)),s=[0,0],l=P.fromPoints(i,r).length,h.toTransform()},projection:p=>{const v=e.canvas.width/e.canvas.height,g=P.fromPoints(i,r).length,d=Math.max(400,g*.8);return _.perspective(u,v,Math.max(.01,g-d),g+d)}}]},Be=async(e,t,r)=>{const i=Ge()(_.scale(10,10,1).translation(0,0,0),{id:"ref-plane",steps:10,color:[.6,.6,1,.2]}),o=document.getElementById(r),n=await createImageBitmap(o),s=Se(e,n);return[[t,s],[i]]};async function Ie(e,t){const r=await Ve(e);await r.setupShaders("standard-3d");const[i,o]=Ae(r,[3,3,3]);r.captureMouseMotion(i),r.beginRenderLoop({camera:o});const n=await Be(r,Ce()(_.scale(1.5,1.5,1.5),{id:"teapot-cube"}),"teapot");await r.setScene(n)}document.querySelector("#app").innerHTML=`
  <div>
    <h2>Hello WebGPU!</h2>
    <div class="main">
      <div class="left">
        <h3>Camera control test</h3>
        <p>Click and move the mouse to rotate the camera.</p>
        <h3>Controls</h3>
        <ul>
          <li>Left mouse button: rotate</li>
          <li>Center mouse button: pan</li>
          <li>Right mouse button: zoom</li>
          <li>Mouse wheel: dolly</li>
          <li>CTRL Mouse wheel: tilt</li>
        </ul>
      </div>
      <div class="right">
        <canvas id="gfx-canvas" width="800" height="600"></canvas>
      </div>
    </div>
    <p id="support">Initializing...</p>
`;const ct=document.getElementById("support"),bt=document.getElementById("gfx-canvas");!ct||!bt?alert("The app is broken! No canvas was found!"):Ie(bt).then(()=>{ct.innerText="All set!"}).catch(e=>{ct.innerText="Error: "+e.message});
