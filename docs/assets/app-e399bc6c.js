(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))i(o);new MutationObserver(o=>{for(const s of o)if(s.type==="childList")for(const n of s.addedNodes)n.tagName==="LINK"&&n.rel==="modulepreload"&&i(n)}).observe(document,{childList:!0,subtree:!0});function r(o){const s={};return o.integrity&&(s.integrity=o.integrity),o.referrerPolicy&&(s.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?s.credentials="include":o.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function i(o){if(o.ep)return;o.ep=!0;const s=r(o);fetch(o.href,s)}})();var kt=Object.defineProperty,$t=(e,t,r)=>t in e?kt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,I=(e,t,r)=>($t(e,typeof t!="symbol"?t+"":t,r),r),at=1e-6,B=typeof Float32Array<"u"?Float32Array:Array;Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});function It(){var e=new B(9);return B!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}function qt(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e}function Y(){var e=new B(16);return B!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function O(e){var t=new B(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function Ht(e,t,r,i,o,s,n,a,c,l,u,h,f,p,v,m){var d=new B(16);return d[0]=e,d[1]=t,d[2]=r,d[3]=i,d[4]=o,d[5]=s,d[6]=n,d[7]=a,d[8]=c,d[9]=l,d[10]=u,d[11]=h,d[12]=f,d[13]=p,d[14]=v,d[15]=m,d}function gt(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function Xt(e,t){if(e===t){var r=t[1],i=t[2],o=t[3],s=t[6],n=t[7],a=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=r,e[6]=t[9],e[7]=t[13],e[8]=i,e[9]=s,e[11]=t[14],e[12]=o,e[13]=n,e[14]=a}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}function C(e,t){var r=t[0],i=t[1],o=t[2],s=t[3],n=t[4],a=t[5],c=t[6],l=t[7],u=t[8],h=t[9],f=t[10],p=t[11],v=t[12],m=t[13],d=t[14],y=t[15],P=r*a-i*n,M=r*c-o*n,_=r*l-s*n,g=i*c-o*a,w=i*l-s*a,G=o*l-s*c,U=u*m-h*v,Z=u*d-f*v,k=u*y-p*v,$=h*d-f*m,q=h*y-p*m,H=f*y-p*d,L=P*H-M*q+_*$+g*k-w*Z+G*U;return L?(L=1/L,e[0]=(a*H-c*q+l*$)*L,e[1]=(o*q-i*H-s*$)*L,e[2]=(m*G-d*w+y*g)*L,e[3]=(f*w-h*G-p*g)*L,e[4]=(c*k-n*H-l*Z)*L,e[5]=(r*H-o*k+s*Z)*L,e[6]=(d*_-v*G-y*M)*L,e[7]=(u*G-f*_+p*M)*L,e[8]=(n*q-a*k+l*U)*L,e[9]=(i*k-r*q-s*U)*L,e[10]=(v*w-m*_+y*P)*L,e[11]=(h*_-u*w-p*P)*L,e[12]=(a*Z-n*$-c*U)*L,e[13]=(r*$-i*Z+o*U)*L,e[14]=(m*M-v*g-d*P)*L,e[15]=(u*g-h*M+f*P)*L,e):null}function _t(e,t,r){var i=t[0],o=t[1],s=t[2],n=t[3],a=t[4],c=t[5],l=t[6],u=t[7],h=t[8],f=t[9],p=t[10],v=t[11],m=t[12],d=t[13],y=t[14],P=t[15],M=r[0],_=r[1],g=r[2],w=r[3];return e[0]=M*i+_*a+g*h+w*m,e[1]=M*o+_*c+g*f+w*d,e[2]=M*s+_*l+g*p+w*y,e[3]=M*n+_*u+g*v+w*P,M=r[4],_=r[5],g=r[6],w=r[7],e[4]=M*i+_*a+g*h+w*m,e[5]=M*o+_*c+g*f+w*d,e[6]=M*s+_*l+g*p+w*y,e[7]=M*n+_*u+g*v+w*P,M=r[8],_=r[9],g=r[10],w=r[11],e[8]=M*i+_*a+g*h+w*m,e[9]=M*o+_*c+g*f+w*d,e[10]=M*s+_*l+g*p+w*y,e[11]=M*n+_*u+g*v+w*P,M=r[12],_=r[13],g=r[14],w=r[15],e[12]=M*i+_*a+g*h+w*m,e[13]=M*o+_*c+g*f+w*d,e[14]=M*s+_*l+g*p+w*y,e[15]=M*n+_*u+g*v+w*P,e}function rt(e,t,r){var i=r[0],o=r[1],s=r[2],n,a,c,l,u,h,f,p,v,m,d,y;return t===e?(e[12]=t[0]*i+t[4]*o+t[8]*s+t[12],e[13]=t[1]*i+t[5]*o+t[9]*s+t[13],e[14]=t[2]*i+t[6]*o+t[10]*s+t[14],e[15]=t[3]*i+t[7]*o+t[11]*s+t[15]):(n=t[0],a=t[1],c=t[2],l=t[3],u=t[4],h=t[5],f=t[6],p=t[7],v=t[8],m=t[9],d=t[10],y=t[11],e[0]=n,e[1]=a,e[2]=c,e[3]=l,e[4]=u,e[5]=h,e[6]=f,e[7]=p,e[8]=v,e[9]=m,e[10]=d,e[11]=y,e[12]=n*i+u*o+v*s+t[12],e[13]=a*i+h*o+m*s+t[13],e[14]=c*i+f*o+d*s+t[14],e[15]=l*i+p*o+y*s+t[15]),e}function Yt(e,t,r){var i=r[0],o=r[1],s=r[2];return e[0]=t[0]*i,e[1]=t[1]*i,e[2]=t[2]*i,e[3]=t[3]*i,e[4]=t[4]*o,e[5]=t[5]*o,e[6]=t[6]*o,e[7]=t[7]*o,e[8]=t[8]*s,e[9]=t[9]*s,e[10]=t[10]*s,e[11]=t[11]*s,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function zt(e,t,r){var i=Math.sin(r),o=Math.cos(r),s=t[4],n=t[5],a=t[6],c=t[7],l=t[8],u=t[9],h=t[10],f=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=s*o+l*i,e[5]=n*o+u*i,e[6]=a*o+h*i,e[7]=c*o+f*i,e[8]=l*o-s*i,e[9]=u*o-n*i,e[10]=h*o-a*i,e[11]=f*o-c*i,e}function Gt(e,t,r){var i=Math.sin(r),o=Math.cos(r),s=t[0],n=t[1],a=t[2],c=t[3],l=t[8],u=t[9],h=t[10],f=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=s*o-l*i,e[1]=n*o-u*i,e[2]=a*o-h*i,e[3]=c*o-f*i,e[8]=s*i+l*o,e[9]=n*i+u*o,e[10]=a*i+h*o,e[11]=c*i+f*o,e}function Bt(e,t,r){var i=Math.sin(r),o=Math.cos(r),s=t[0],n=t[1],a=t[2],c=t[3],l=t[4],u=t[5],h=t[6],f=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=s*o+l*i,e[1]=n*o+u*i,e[2]=a*o+h*i,e[3]=c*o+f*i,e[4]=l*o-s*i,e[5]=u*o-n*i,e[6]=h*o-a*i,e[7]=f*o-c*i,e}function Zt(e,t,r){var i=t[0],o=t[1],s=t[2],n=t[3],a=i+i,c=o+o,l=s+s,u=i*a,h=i*c,f=i*l,p=o*c,v=o*l,m=s*l,d=n*a,y=n*c,P=n*l;return e[0]=1-(p+m),e[1]=h+P,e[2]=f-y,e[3]=0,e[4]=h-P,e[5]=1-(u+m),e[6]=v+d,e[7]=0,e[8]=f+y,e[9]=v-d,e[10]=1-(u+p),e[11]=0,e[12]=r[0],e[13]=r[1],e[14]=r[2],e[15]=1,e}function jt(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}function Wt(e,t){var r=t[0],i=t[1],o=t[2],s=t[4],n=t[5],a=t[6],c=t[8],l=t[9],u=t[10];return e[0]=Math.hypot(r,i,o),e[1]=Math.hypot(s,n,a),e[2]=Math.hypot(c,l,u),e}function Kt(e,t,r,i){var o=t[0],s=t[1],n=t[2],a=t[3],c=o+o,l=s+s,u=n+n,h=o*c,f=o*l,p=o*u,v=s*l,m=s*u,d=n*u,y=a*c,P=a*l,M=a*u,_=i[0],g=i[1],w=i[2];return e[0]=(1-(v+d))*_,e[1]=(f+M)*_,e[2]=(p-P)*_,e[3]=0,e[4]=(f-M)*g,e[5]=(1-(h+d))*g,e[6]=(m+y)*g,e[7]=0,e[8]=(p+P)*w,e[9]=(m-y)*w,e[10]=(1-(h+v))*w,e[11]=0,e[12]=r[0],e[13]=r[1],e[14]=r[2],e[15]=1,e}function Qt(e,t){var r=t[0],i=t[1],o=t[2],s=t[3],n=r+r,a=i+i,c=o+o,l=r*n,u=i*n,h=i*a,f=o*n,p=o*a,v=o*c,m=s*n,d=s*a,y=s*c;return e[0]=1-h-v,e[1]=u+y,e[2]=f-d,e[3]=0,e[4]=u-y,e[5]=1-l-v,e[6]=p+m,e[7]=0,e[8]=f+d,e[9]=p-m,e[10]=1-l-h,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function Jt(e,t,r,i,o){var s=1/Math.tan(t/2),n;return e[0]=s/r,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=s,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,o!=null&&o!==1/0?(n=1/(i-o),e[10]=(o+i)*n,e[14]=2*o*i*n):(e[10]=-1,e[14]=-2*i),e}var te=Jt;function At(e,t,r,i){var o,s,n,a,c,l,u,h,f,p,v=t[0],m=t[1],d=t[2],y=i[0],P=i[1],M=i[2],_=r[0],g=r[1],w=r[2];return Math.abs(v-_)<at&&Math.abs(m-g)<at&&Math.abs(d-w)<at?gt(e):(u=v-_,h=m-g,f=d-w,p=1/Math.hypot(u,h,f),u*=p,h*=p,f*=p,o=P*f-M*h,s=M*u-y*f,n=y*h-P*u,p=Math.hypot(o,s,n),p?(p=1/p,o*=p,s*=p,n*=p):(o=0,s=0,n=0),a=h*n-f*s,c=f*o-u*n,l=u*s-h*o,p=Math.hypot(a,c,l),p?(p=1/p,a*=p,c*=p,l*=p):(a=0,c=0,l=0),e[0]=o,e[1]=a,e[2]=u,e[3]=0,e[4]=s,e[5]=c,e[6]=h,e[7]=0,e[8]=n,e[9]=l,e[10]=f,e[11]=0,e[12]=-(o*v+s*m+n*d),e[13]=-(a*v+c*m+l*d),e[14]=-(u*v+h*m+f*d),e[15]=1,e)}function J(){var e=new B(3);return B!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function ee(e){var t=e[0],r=e[1],i=e[2];return Math.hypot(t,r,i)}function st(e,t,r){var i=new B(3);return i[0]=e,i[1]=t,i[2]=r,i}function re(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e}function ie(e,t){var r=t[0],i=t[1],o=t[2],s=r*r+i*i+o*o;return s>0&&(s=1/Math.sqrt(s)),e[0]=t[0]*s,e[1]=t[1]*s,e[2]=t[2]*s,e}function wt(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function ot(e,t,r){var i=t[0],o=t[1],s=t[2],n=r[0],a=r[1],c=r[2];return e[0]=o*c-s*a,e[1]=s*n-i*c,e[2]=i*a-o*n,e}var oe=ee;(function(){var e=J();return function(t,r,i,o,s,n){var a,c;for(r||(r=3),i||(i=0),o?c=Math.min(o*r+i,t.length):c=t.length,a=i;a<c;a+=r)e[0]=t[a],e[1]=t[a+1],e[2]=t[a+2],s(e,e,n),t[a]=e[0],t[a+1]=e[1],t[a+2]=e[2];return t}})();function Ft(){var e=new B(4);return B!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0,e[3]=0),e}function se(e){var t=new B(4);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t}function z(e,t,r,i){var o=new B(4);return o[0]=e,o[1]=t,o[2]=r,o[3]=i,o}function Dt(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e[3]=t[3]+r[3],e}function Et(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e[3]=t[3]-r[3],e}function ne(e,t,r){return e[0]=t[0]*r[0],e[1]=t[1]*r[1],e[2]=t[2]*r[2],e[3]=t[3]*r[3],e}function ae(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e}function ce(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=-t[3],e}function Q(e,t){var r=t[0],i=t[1],o=t[2],s=t[3],n=r*r+i*i+o*o+s*s;return n>0&&(n=1/Math.sqrt(n)),e[0]=r*n,e[1]=i*n,e[2]=o*n,e[3]=s*n,e}function D(e,t,r){var i=t[0],o=t[1],s=t[2],n=t[3];return e[0]=r[0]*i+r[4]*o+r[8]*s+r[12]*n,e[1]=r[1]*i+r[5]*o+r[9]*s+r[13]*n,e[2]=r[2]*i+r[6]*o+r[10]*s+r[14]*n,e[3]=r[3]*i+r[7]*o+r[11]*s+r[15]*n,e}(function(){var e=Ft();return function(t,r,i,o,s,n){var a,c;for(r||(r=4),i||(i=0),o?c=Math.min(o*r+i,t.length):c=t.length,a=i;a<c;a+=r)e[0]=t[a],e[1]=t[a+1],e[2]=t[a+2],e[3]=t[a+3],s(e,e,n),t[a]=e[0],t[a+1]=e[1],t[a+2]=e[2],t[a+3]=e[3];return t}})();function lt(){var e=new B(4);return B!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function ue(e,t,r){r=r*.5;var i=Math.sin(r);return e[0]=i*t[0],e[1]=i*t[1],e[2]=i*t[2],e[3]=Math.cos(r),e}function le(e,t,r){var i=t[0],o=t[1],s=t[2],n=t[3],a=r[0],c=r[1],l=r[2],u=r[3];return e[0]=i*u+n*a+o*l-s*c,e[1]=o*u+n*c+s*a-i*l,e[2]=s*u+n*l+i*c-o*a,e[3]=n*u-i*a-o*c-s*l,e}function he(e,t,r){r*=.5;var i=t[0],o=t[1],s=t[2],n=t[3],a=Math.sin(r),c=Math.cos(r);return e[0]=i*c+n*a,e[1]=o*c+s*a,e[2]=s*c-o*a,e[3]=n*c-i*a,e}function de(e,t,r){r*=.5;var i=t[0],o=t[1],s=t[2],n=t[3],a=Math.sin(r),c=Math.cos(r);return e[0]=i*c-s*a,e[1]=o*c+n*a,e[2]=s*c+i*a,e[3]=n*c-o*a,e}function fe(e,t,r){r*=.5;var i=t[0],o=t[1],s=t[2],n=t[3],a=Math.sin(r),c=Math.cos(r);return e[0]=i*c+o*a,e[1]=o*c-i*a,e[2]=s*c+n*a,e[3]=n*c-s*a,e}function dt(e,t,r,i){var o=t[0],s=t[1],n=t[2],a=t[3],c=r[0],l=r[1],u=r[2],h=r[3],f,p,v,m,d;return p=o*c+s*l+n*u+a*h,p<0&&(p=-p,c=-c,l=-l,u=-u,h=-h),1-p>at?(f=Math.acos(p),v=Math.sin(f),m=Math.sin((1-i)*f)/v,d=Math.sin(i*f)/v):(m=1-i,d=i),e[0]=m*o+d*c,e[1]=m*s+d*l,e[2]=m*n+d*u,e[3]=m*a+d*h,e}function K(e,t){var r=t[0],i=t[1],o=t[2],s=t[3],n=r*r+i*i+o*o+s*s,a=n?1/n:0;return e[0]=-r*a,e[1]=-i*a,e[2]=-o*a,e[3]=s*a,e}function Rt(e,t){var r=t[0]+t[4]+t[8],i;if(r>0)i=Math.sqrt(r+1),e[3]=.5*i,i=.5/i,e[0]=(t[5]-t[7])*i,e[1]=(t[6]-t[2])*i,e[2]=(t[1]-t[3])*i;else{var o=0;t[4]>t[0]&&(o=1),t[8]>t[o*3+o]&&(o=2);var s=(o+1)%3,n=(o+2)%3;i=Math.sqrt(t[o*3+o]-t[s*3+s]-t[n*3+n]+1),e[o]=.5*i,i=.5/i,e[3]=(t[s*3+n]-t[n*3+s])*i,e[s]=(t[s*3+o]+t[o*3+s])*i,e[n]=(t[n*3+o]+t[o*3+n])*i}return e}var ft=se,pe=z,Ut=Q;(function(){var e=J(),t=st(1,0,0),r=st(0,1,0);return function(i,o,s){var n=wt(o,s);return n<-.999999?(ot(e,t,o),oe(e)<1e-6&&ot(e,r,o),ie(e,e),ue(i,e,Math.PI),i):n>.999999?(i[0]=0,i[1]=0,i[2]=0,i[3]=1,i):(ot(e,o,s),i[0]=e[0],i[1]=e[1],i[2]=e[2],i[3]=1+n,Ut(i,i))}})();(function(){var e=lt(),t=lt();return function(r,i,o,s,n,a){return dt(e,i,n,a),dt(t,o,s,a),dt(r,e,t,2*a*(1-a)),r}})();(function(){var e=It();return function(t,r,i,o){return e[0]=i[0],e[3]=i[1],e[6]=i[2],e[1]=o[0],e[4]=o[1],e[7]=o[2],e[2]=-r[0],e[5]=-r[1],e[8]=-r[2],Ut(t,Rt(t,e))}})();const ct=class E{constructor(){I(this,"_coord"),I(this,"scale",t=>{const r=new E;return ae(r._coord,this._coord,t),r}),I(this,"dot",t=>wt(this.vec3(),t.vec3())),I(this,"add",t=>{const r=new E;return Dt(r._coord,this._coord,t._coord),r}),I(this,"multiply",t=>{const r=new E;return ne(r._coord,this._coord,t._coord),r}),this._coord=z(0,0,0,0)}static get bufferSize(){return 4*4}static fromValues(t,r,i){const o=new E;return o._coord=z(t,r,i,0),o}static fromVec4(t){const r=new E,i=t[3]!==0?t[3]:1;return r._coord=z(t[0]/i,t[1]/i,t[2]/i,0),r}static fromVec3(t){const r=new E;return r._coord=z(t[0],t[1],t[2],0),r}static fromPoints(t,r){const i=new E;return Et(i._coord,t.vec4(),r.vec4()),i}static fromPoint(t){const r=new E;return r._coord=[...t.triplet,0],r}toString(){return`Vector(${this.x}, ${this.y}, ${this.z})`}map(t){const r=new E;return t.isFrame()?D(r._coord,this._coord,t.inverseMatrix):D(r._coord,this._coord,t.directMatrix),r}unMap(t){const r=new E;return t.isFrame()?D(r._coord,this._coord,t.directMatrix):D(r._coord,this._coord,t.inverseMatrix),r}relative(t){return this.map(t)}absolute(t){return this.unMap(t)}isUnitVector(){return!1}get x(){return this._coord[0]}get y(){return this._coord[1]}get z(){return this._coord[2]}get triplet(){return[this.x,this.y,this.z]}get coordinates(){return[...this._coord.values()]}buffer(){return new Float32Array(this.coordinates)}get length(){const t=this._coord[0],r=this._coord[1],i=this._coord[2];return Math.sqrt(t*t+r*r+i*i)}get lengthSquare(){const t=this._coord[0],r=this._coord[1],i=this._coord[2];return t*t+r*r+i*i}vec3(){return st(this.x,this.y,this.z)}vec4(){return z(this.x,this.y,this.z,0)}};I(ct,"crossProduct",(e,t)=>{const r=J();return ot(r,e.vec3(),t.vec3()),ct.fromVec3(r)}),I(ct,"dot",(e,t)=>wt(e.vec3(),t.vec3()));let T=ct;class b{constructor(){I(this,"_coord"),this._coord=z(0,0,0,1)}static get bufferSize(){return 4*4}static origin(){return new b}static fromValues(t,r,i,o=1){const s=new b;return s._coord=z(t/o,r/o,i/o,1),s}static fromVector(t){const r=new b;return r._coord=z(t.x,t.y,t.z,1),r}static fromVec4(t){const r=new b,i=t[3]!==0?t[3]:1;return r._coord=z(t[0]/i,t[1]/i,t[2]/i,1),r}static fromVec3(t){const r=new b;return r._coord=z(t[0],t[1],t[2],1),r}toString(){return`Point(${this.x}, ${this.y}, ${this.z})`}map(t){const r=new b;return t.isFrame()?D(r._coord,this._coord,t.inverseMatrix):D(r._coord,this._coord,t.directMatrix),r}unMap(t){const r=new b;return t.isFrame()?D(r._coord,this._coord,t.directMatrix):D(r._coord,this._coord,t.inverseMatrix),r}relative(t){return this.map(t)}absolute(t){return this.unMap(t)}static relative(t,r){return t.map(r)}static absolute(t,r){return t.unMap(r)}subtract(t){const r=Ft();return Et(r,this._coord,t._coord),T.fromVec4(r)}scale(t){const r=J();return re(r,this.vec3(),t),b.fromVec3(r)}add(t){const r=new b;return Dt(r._coord,this._coord,t.vec4()),r}isPoint(){return!0}get x(){return this._coord[0]}get y(){return this._coord[1]}get z(){return this._coord[2]}get coordinates(){return[...this._coord.values()]}get triplet(){return[this.x,this.y,this.z]}buffer(){return new Float32Array(this.coordinates)}vec3(){return st(this.x,this.y,this.z)}vec4(){return z(this.x,this.y,this.z,1)}}const xt=class X{constructor(){I(this,"_coord"),this._coord=z(1,1,1,0)}static get bufferSize(){return 4*4}static fromVector(t){const r=new X;return r._coord=z(t.x,t.y,t.z,0),Q(r._coord,r._coord),r}fromPoint(t){return X.fromValues(...t.triplet)}static fromValues(t,r,i){const o=z(t,r,i,0);return Q(o,o),X.fromVec4(o)}static fromVec4(t){const r=new X,i=t[3]!==0?t[3]:1;return r._coord=z(t[0]/i,t[1]/i,t[2]/i,0),Q(r._coord,r._coord),r}static fromVec3(t){const r=new X;return r._coord=z(t[0],t[1],t[2],0),Q(r._coord,r._coord),r}toString(){return`UnitVector(${this.x}, ${this.y}, ${this.z})`}map(t){const r=new X;return t.isFrame()?D(r._coord,this._coord,t.inverseMatrix):D(r._coord,this._coord,t.directMatrix),Q(r._coord,r._coord),r}unMap(t){const r=new X;return t.isFrame()?D(r._coord,this._coord,t.directMatrix):D(r._coord,this._coord,t.inverseMatrix),Q(r._coord,r._coord),r}relative(t){return this.map(t)}absolute(t){return this.unMap(t)}invert(){const t=new X;return ce(t._coord,this._coord),t}scale(t){return T.fromValues(this.x*t,this.y*t,this.z*t)}isUnitVector(){return!0}get x(){return this._coord[0]}get y(){return this._coord[1]}get z(){return this._coord[2]}get length(){return 1}get coordinates(){return[...this._coord.values()]}get triplet(){return[this.x,this.y,this.z]}buffer(){return new Float32Array(this.coordinates)}vec3(){return st(this.x,this.y,this.z)}};I(xt,"crossProduct",(e,t)=>{const r=J();return ot(r,e.vec3(),t.vec3()),xt.fromVec3(r)});let V=xt;const Vt=e=>e.isUnitVector();class x{constructor(){I(this,"_direct"),I(this,"_inverse"),I(this,"_isIdentity",!0),this._direct=Y(),this._inverse=Y(),C(this._inverse,this._direct)}static get bufferSize(){return 16*4}static world(){return new x}static identity(){return new x}static fromRotation(t){const r=new x;return Qt(r._direct,t.quat),C(r._inverse,r._direct),r._isIdentity=!1,r}static fromMat4(t){const r=new x,i=Y();return C(i,t),r._direct=O(t),r._inverse=O(i),r._isIdentity=!1,r}static lookAt(t,r,i){const o=new x;return At(o._direct,t.vec3(),r.vec3(),i.vec3()),C(o._inverse,o._direct),o._isIdentity=!1,o}static perspective(t,r,i,o){const s=new x;return te(s._direct,t,r,i,o),C(s._inverse,s._direct),s._isIdentity=!1,s}static invert(t){const r=new x;return r._direct=O(t._inverse),r._inverse=O(t._direct),r._isIdentity=!1,r}static translation(t,r,i){const o=new x;return rt(o._direct,o._direct,[t,r,i]),C(o._inverse,o._direct),o._isIdentity=!1,o}static move(t){const r=new x;return rt(r._direct,r._direct,t.vec3()),C(r._inverse,r._direct),r._isIdentity=!1,r}static rotationX(t){const r=new x;return zt(r._direct,r._direct,t),C(r._inverse,r._direct),r._isIdentity=!1,r}static rotationY(t){const r=new x;return Gt(r._direct,r._direct,t),C(r._inverse,r._direct),r._isIdentity=!1,r}static rotationZ(t){const r=new x;return Bt(r._direct,r._direct,t),C(r._inverse,r._direct),r._isIdentity=!1,r}static scale(t,r,i){const o=new x;return Yt(o._direct,o._direct,[t,r,i]),C(o._inverse,o._direct),o._isIdentity=!1,o}static rotoTranslation(t,r){const i=new x;return Zt(i._direct,t.quat,r.vec3()),C(i._inverse,i._direct),i._isIdentity=!1,i}static fromRotationTranslationScale(t,r,i){const o=new x;return Kt(o._direct,t.quat,r.vec3(),i.vec3()),C(o._inverse,o._direct),o._isIdentity=!1,o}isFrame(){return!1}get values(){return this._direct.values()}get inverseValues(){return this._inverse.values()}buffer(){return new Float32Array(this._direct.values())}inverseBuffer(){return new Float32Array(this._inverse.values())}apply(t){return t.map(this)}compose(t){const r=new x,{_direct:i,_inverse:o}=this,{_direct:s,_inverse:n}=t;return _t(r._direct,s,i),_t(r._inverse,o,n),r._isIdentity=!1,r}transpose(){const t=new x;return Xt(t._direct,this._direct),C(t._inverse,t._direct),t._isIdentity=!1,t}translation(t,r,i){const o=x.translation(t,r,i);return this.compose(o)}rotationX(t){const r=x.rotationX(t);return this.compose(r)}rotationY(t){const r=x.rotationY(t);return this.compose(r)}rotationZ(t){const r=x.rotationZ(t);return this.compose(r)}scale(t,r,i){const o=x.scale(t,r,i);return this.compose(o)}invert(){const t=new x;return t._direct=O(this._inverse),t._inverse=O(this._direct),t._isIdentity=this._isIdentity,t}get directMatrix(){return this._direct}get inverseMatrix(){return this._inverse}get isIdentity(){return this._isIdentity}get scaleVector(){const t=J();return Wt(t,this._direct),T.fromValues(t[0],t[1],t[2])}get positionVector(){const t=J();return jt(t,this._direct),T.fromValues(t[0],t[1],t[2])}}const yt=class N{constructor(){I(this,"_direct"),I(this,"_inverse"),this._direct=Y(),this._inverse=Y(),gt(this._direct),gt(this._inverse)}static bufferSize(){return 16*4}static world(){return new N}static translation(t){const r=new N,i=Y();return rt(i,i,t.vec3()),r._inverse=i,C(r._direct,r._inverse),r}static rotationX(t,r){const i=new N,o=Y();return rt(o,o,t.vec3()),zt(o,o,r),i._direct=o,C(i._inverse,i._direct),i}static rotationY(t,r){const i=new N,o=Y();return rt(o,o,t.vec3()),Gt(o,o,r),i._direct=o,C(i._inverse,i._direct),i}static rotationZ(t,r){const i=new N,o=Y();return rt(o,o,t.vec3()),Bt(o,o,r),i._direct=o,C(i._inverse,i._direct),i}static lookAt(t,r,i){const o=new N;return At(o._inverse,t.vec3(),r.vec3(),i.vec3()),C(o._direct,o._inverse),o}isFrame(){return!0}toString(){return`Frame(${this.origin}, ${this.i}, ${this.j}, ${this.k})`}map(t){return this.compose(t)}unMap(t){return this.invert().compose(t)}compose(t){const r=new N,{_direct:i}=this,{_direct:o}=t;return _t(r._direct,o,i),C(r._inverse,r._direct),r}toTransform(){return x.fromMat4(this._inverse)}invert(){const t=new N;return t._direct=O(this._inverse),t._inverse=O(this._direct),t}get directMatrix(){return O(this._direct)}get inverseMatrix(){return O(this._inverse)}get i(){return V.fromValues(this._direct[0],this._direct[1],this._direct[2])}get j(){return V.fromValues(this._direct[4],this._direct[5],this._direct[6])}get k(){return V.fromValues(this._direct[8],this._direct[9],this._direct[10])}get o(){return b.fromValues(this._direct[12],this._direct[13],this._direct[14],this._direct[15])}get origin(){return b.fromValues(this._inverse[12],this._inverse[13],this._inverse[14],this._inverse[15])}relative(t){if(t&&ve(t)){const r=this.origin.relative(t),i=this.k.relative(t),o=this.i.relative(t);return N.from2Vectors(r,i,o)}return t.relative(this)}};I(yt,"from2Vectors",(e,t,r)=>{const i=new yt,o=Vt(t)?t:V.fromVector(t),s=V.crossProduct(o,Vt(r)?r:V.fromVector(r)),n=[...V.crossProduct(s,o).coordinates,...s.coordinates,...o.coordinates,...e.coordinates];return i._direct=Ht(...n),C(i._inverse,i._direct),i});let bt=yt;const ve=e=>e&&e.isFrame!==void 0?e.isFrame():!1;class R{constructor(){I(this,"_direct"),I(this,"_inverse"),this._direct=lt(),this._inverse=lt()}static identity(){return new R}static fromValues(t,r,i,o){const s=new R;return s._direct=pe(t,r,i,o),K(s._inverse,s._direct),s}static fromQuat(t){const r=new R;return r._direct=ft(t),K(r._inverse,r._direct),r}static fromTransform(t){const r=It();qt(r,t.directMatrix);const i=new R;return i._direct=Rt(i._direct,r),K(i._inverse,i._direct),i}static rotationX(t){const r=new R;return he(r._direct,r._direct,t),K(r._inverse,r._direct),r}static rotationY(t){const r=new R;return de(r._direct,r._direct,t),K(r._inverse,r._direct),r}static rotationZ(t){const r=new R;return fe(r._direct,r._direct,t),K(r._inverse,r._direct),r}inverse(){const t=new R;return t._direct=ft(this._inverse),t._inverse=ft(this._direct),t}compose(t){const r=new R;return le(r._direct,this._direct,t._direct),K(r._inverse,r._direct),r}get quat(){return this._direct}}const W=e=>e/180*Math.PI;var me=Object.defineProperty,ge=(e,t,r)=>t in e?me(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,S=(e,t,r)=>(ge(e,typeof t!="symbol"?t+"":t,r),r);const St=()=>{let e=0,t=performance.now(),r=0;const i=[];return{getFPS:()=>i.reduce((o,s)=>o+s,0)/i.length,measureFPS:()=>(e=performance.now()-t,e<=1?i[r]:(r=(r+1)%10,i[r]=1e3/e,t=performance.now(),e)),getLastTimeSpan:()=>e}},_e=async({context:e,device:t,format:r},i)=>{e.configure({device:t,format:r,alphaMode:"opaque"});const o=t.createShaderModule({code:i});return(await o.getCompilationInfo()).messages.forEach(s=>{let n=s.message;s.lineNum&&(n=`Line ${s.lineNum}:${s.linePos} - "${i.substr(s.offset,s.length+40)}"
`+s.message),console.error("WGSL error: ",n)}),o},xe=(e,t,r=GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST)=>{const i=e.createBuffer({size:t.byteLength,usage:r,mappedAtCreation:!0});return new Float32Array(i.getMappedRange()).set(t),i.unmap(),i},Pt=e=>{const{device:t,canvas:r}=e,i=t.createTexture({size:{width:r.width,height:r.height,depthOrArrayLayers:1},sampleCount:1,format:e.format,usage:GPUTextureUsage.RENDER_ATTACHMENT}),o=t.createTexture({label:"DepthTexture",sampleCount:1,size:[r.width,r.height,1],format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT}),s=De(window.getComputedStyle(r).backgroundColor);return{colorAttachments:[{view:i.createView(),clearValue:s,loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:o.createView(),depthClearValue:1,depthStoreOp:"store",depthLoadOp:"clear"}}},ye=async e=>{const t=await navigator.gpu.requestAdapter({powerPreference:"high-performance"});if(!t)throw new Error("WebGPU:adapter is NOT available!");const r=await t.requestDevice();if(!r)throw new Error("WebGPU:device is NOT available!");const i=e.getContext("webgpu");if(!i)throw new Error("WebGPU:context from instantiated Canvas not available!");const o=navigator.gpu.getPreferredCanvasFormat();i.configure({device:r,format:o,usage:GPUTextureUsage.RENDER_ATTACHMENT,alphaMode:"opaque"});const s=await t.requestAdapterInfo();return console.info("WebGPU: adapter:",s),console.info("WebGPU: fallback adapter:",t.isFallbackAdapter),console.info("WegGPU: maxBindGroups:",r.limits.maxBindGroups),{context:i,device:r,canvas:e,format:o}},be=e=>typeof e=="string",we=(e,[t,r],i)=>({view:i&&i.view?i.view(e.view):x.lookAt(b.fromValues(-5,-5,-5),b.fromValues(0,0,0),V.fromValues(0,0,1)),projection:i&&i.projection?i.projection(e.projection):x.perspective(Math.PI/5,t/r,.1,100)}),Me=(e,t)=>Math.log(e)/Math.log(t),Ve=e=>e!==null,Se=e=>{const t=3*x.bufferSize+8+4*(2*T.bufferSize)+4*(T.bufferSize+b.bufferSize),r=4,i=r*(2*T.bufferSize)+r*(T.bufferSize+b.bufferSize)+4*4,o=e.device.createBuffer({label:"TransBuffer",size:t+t%16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),s=e.device.createBuffer({label:"LightBuffer",size:i+i%16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),n=[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}],a=e.device.createBindGroupLayout({label:"transformations",entries:n}),c=[{binding:0,resource:{buffer:o}},{binding:1,resource:{buffer:s}}],l=e.device.createBindGroup({label:"SceneData",layout:a,entries:c});return[a,l,[o,s]]},Pe=e=>{const t=2*x.bufferSize,r=e.device.createBuffer({label:"TransBuffer",size:t+t%16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),i=[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}],o=e.device.createBindGroupLayout({label:"modelTransf",entries:i}),s=[{binding:0,resource:{buffer:r}}],n=e.device.createBindGroup({label:"SceneData",layout:o,entries:s});return[o,n,[r]]},Te=e=>{const t=e.device.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),r=e.device.createBuffer({size:4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),i=[{binding:0,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}],o=e.device.createBindGroupLayout({label:"color",entries:i}),s=[{binding:0,resource:{buffer:t}},{binding:1,resource:{buffer:r}}],n=e.device.createBindGroup({label:"color",layout:o,entries:s});return[o,n,[t]]},Le=(e,t)=>{const{device:r}=e,i={addressModeU:"repeat",addressModeV:"repeat",magFilter:"linear",minFilter:"linear",mipmapFilter:"linear",maxAnisotropy:1},o=r.createSampler(i),s=t.views.filter(Ve),n=[...s.map((u,h)=>({binding:h,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"float"}})),{binding:4,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}}],a=e.device.createBindGroupLayout({label:"texture",entries:n}),c=[...s.map((u,h)=>({binding:h,resource:u})),{binding:4,resource:o}],l=e.device.createBindGroup({label:"texture",layout:a,entries:c});return[a,l]},Ce=(e,t)=>{const{device:r}=e,[i,o,s]=Se(e),[n,a,c]=Te(e),[l,u,h]=Pe(e),[f,p]=t?Le(e,t):[void 0,void 0],v=f?[i,n,l,f]:[i,n,l],m={sceneGroup:o,colorGroup:a,modelGroup:u,texturesGroup:p},d={sceneBuffers:s,colorBuffers:c,modelBuffers:h};return[r.createPipelineLayout({bindGroupLayouts:v}),m,d]},Tt=(e,t,r)=>{const{device:i,format:o}=e,s=r.map(n=>{const[a,c,l]=Ce(e,n.material),u={label:n.label,layout:a,multisample:{count:1},vertex:{module:t,entryPoint:n.vertexShader,buffers:[n.bufferLayout]},fragment:{module:t,entryPoint:n.fragmentShader,targets:[{format:o,blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"}}}]},primitive:{topology:n.primitives,cullMode:n.cullMode},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"}},h=i.createRenderPipeline(u),f={...u,label:`${n.label}-alt`,primitive:{topology:"line-list",cullMode:"none"}},p=i.createRenderPipeline(f);return[n.id,{id:n.id,type:n.label,pipeline:h,altPipeline:p,geoRenderable:n,uniformBuffers:l,bindGroups:c}]});return new Map(s)},Ie=(e,t)=>{let r="none",i=[0,0],o=[0,0],s=[0,0];e.addEventListener("contextmenu",n=>{n.preventDefault()}),e.addEventListener("wheel",n=>{n.ctrlKey?t.tilt(n.deltaY):t.zoom(n.deltaY)}),e.addEventListener("pointerdown",n=>{e.setPointerCapture(n.pointerId),i=[n.offsetX,n.offsetY],o=[0,0],s=i,r=`${n.ctrlKey?"ctrl-":""}mouse-${n.button}`,t.move(r,{origin:i,direction:o},s)}),e.addEventListener("pointermove",n=>{if(r==="none")return;const a=[n.offsetX,n.offsetY];o=[a[0]-s[0],a[1]-s[1]],s=a,t.move(r,{origin:i,direction:o},s)}),e.addEventListener("pointerup",n=>{e.releasePointerCapture(n.pointerId);const a=[n.offsetX,n.offsetY];o=[a[0]-i[0],a[1]-i[1]],o[0]<=.9&&o[1]<=.9&&t.click("none",a),t.move("none",{origin:i,direction:o},a),r="none"})},ze=`const MAX_DIR_LIGHTS: u32 = 4;
const MAX_POINT_LIGHTS: u32 = 4;

struct DirectionalLight {
  dir: vec4<f32>,
  col: vec4<f32>,
};

struct PointLight {
  pos: vec4<f32>,  // Position of the light
  col: vec4<f32>,  // Color of the light
};

struct SceneData {
  view: mat4x4<f32>,
  invertView: mat4x4<f32>,
  projection: mat4x4<f32>,
};

struct ModelData {
  model: mat4x4<f32>,
  modelInverseTranspose: mat4x4<f32>,
};

struct SceneLights {
  dirLights: array<DirectionalLight, MAX_DIR_LIGHTS>,
  pointLights: array<PointLight, MAX_POINT_LIGHTS>,
  ambient: vec4<f32>,
};

struct ObjectData {
  model: mat4x4<f32>,
};

struct TextFragment {
  @builtin(position) position: vec4<f32>,
  @location(0) texCoord: vec2<f32>,
  @location(1) normal: vec3<f32>,
  @location(2) pos: vec3<f32>,
  @location(3) eye: vec3<f32>,
};

struct ColorFragment {
  @builtin(position) position: vec4<f32>,
  @location(0) normal: vec3<f32>,
  @location(1) pos: vec3<f32>,
  @location(2) eye: vec3<f32>,
  @location(3) viewZ: f32,
};

struct ColorLineFragment {
  @builtin(position) position: vec4<f32>,
  @location(0) viewZ: f32,
  @location(1) targetZ: f32,
};

struct ColorData {
    color: vec4<f32>,
};

struct TextureIndex {
    index: u32
};

@group(0) @binding(0) var<uniform> sceneData: SceneData;
@group(0) @binding(1) var<uniform> sceneLights: SceneLights;
@group(1) @binding(0) var<uniform> myColor: ColorData;
@group(1) @binding(1) var<uniform> textureIndex: TextureIndex;
@group(2) @binding(0) var<uniform> myModel: ModelData;
@group(3) @binding(0) var myTexture0: texture_2d<f32>;
@group(3) @binding(1) var myTexture1: texture_2d<f32>;
@group(3) @binding(2) var myTexture2: texture_2d<f32>;
@group(3) @binding(3) var myTexture3: texture_2d<f32>;
@group(3) @binding(4) var mySampler: sampler;

fn computeDiffuseColor(
    eye: vec3<f32>,
    pos: vec3<f32>,
    normal: vec3<f32>,
    sceneLights: SceneLights) -> vec3<f32> {
  let shininess: f32 = 32.0;
  var diffuse: vec3<f32> = sceneLights.ambient.rgb;
  for (var i: u32 = 0; i < MAX_DIR_LIGHTS; i = i + 1) {
    if (sceneLights.dirLights[i].col.a != 0.0) {
      let lightDir: vec3<f32> = -normalize(sceneLights.dirLights[i].dir.xyz); //
      let lightColor: vec3<f32> = sceneLights.dirLights[i].col.rgb;
      var NdotL: f32 = pow(max(dot(normal, lightDir), 0), 2);
      diffuse = diffuse + (NdotL * lightColor);
    }
  }
  for (var i: u32 = 0; i < MAX_POINT_LIGHTS; i = i + 1) {
    if (sceneLights.pointLights[i].col.a != 0.0) {
      let dir = sceneLights.pointLights[i].pos.xyz - pos; //  - pos.xyz;
      let attenuation = 1.0 - clamp(pow( length(dir)/20, 2.0), 0.0, 1.0 );

      let lightDir: vec3<f32> = normalize(dir);
      let lightColor: vec3<f32> = sceneLights.pointLights[i].col.rgb;
      var NdotL: f32 = pow(max(dot(normal, lightDir), 0), 2);
      let diffuseColor = NdotL * lightColor;

      // Specular
      let V = normalize(pos - eye);
      let R = normalize(reflect(lightDir, normal));
      let specularIntensity = pow(max(dot(V, R), 0.0), shininess);
      let specularColor = specularIntensity * lightColor;

      diffuse = diffuse + (diffuseColor+ specularColor) * attenuation;
    }
  }
  return clamp(diffuse, vec3<f32>(0.0, 0.0, 0.0), vec3<f32>(1.0, 1.0, 1.0));
}


// ----------------------------------------------------------------------------------------------- Texture Shaders

@vertex
fn vertexTextureShader(
    @location(0) vertexPosition: vec3<f32>,
    @location(1) vertexTexCoord: vec2<f32>,
    @location(2) vertexNormal: vec3<f32>) -> TextFragment {
  var output: TextFragment;
  var vertex = myModel.model * vec4<f32>(vertexPosition, 1.0);
  output.position = sceneData.projection * sceneData.view * vertex;
  output.texCoord = vec2<f32>(vertexTexCoord);
  output.normal = normalize((myModel.modelInverseTranspose * vec4<f32>(vertexNormal, 0.0)).xyz);
  output.pos = vertex.xyz;
  output.eye = sceneData.invertView[3].xyz;

  return output;
}

@fragment
fn fragmentTextureShader(in: TextFragment) -> @location(0) vec4<f32> {
  let diffuse: vec3<f32> = computeDiffuseColor( in.eye, in.pos, in.normal, sceneLights );
  let texColor: vec4<f32> = textureSample(myTexture0, mySampler, in.texCoord);

  return vec4<f32>(texColor.rgb * diffuse, 1.0);
}

// ----------------------------------------------------------------------------------------------- Color Shaders

@vertex
fn vertexColorShader(
    @location(0) vertexPosition: vec3<f32>,
    @location(1) vertexNormal: vec3<f32>) -> ColorFragment {
  var output: ColorFragment;
  var vertex = myModel.model * vec4<f32>(vertexPosition, 1.0);
  var positionInViewSpace = sceneData.view * vertex;
  var bias = 0.002 * positionInViewSpace.z;

  var biasedPositionInViewSpace = positionInViewSpace - vec4<f32>(0.0, 0.0, bias, 0.0);

  output.normal = normalize((myModel.modelInverseTranspose * vec4<f32>(vertexNormal, 0.0)).xyz);
  output.position = sceneData.projection * sceneData.view * vertex;
  output.pos = vertex.xyz;
  output.eye = sceneData.invertView[3].xyz;
  output.viewZ = -biasedPositionInViewSpace.z;

  return output;
}

@fragment
fn fragmentColorShader(in: ColorFragment) -> @location(0) vec4<f32> {
  let diffuse: vec3<f32> = computeDiffuseColor( in.eye, in.pos, in.normal, sceneLights );
  let att: f32 =  1.0 - clamp(in.viewZ / 300, 0.2, 1.0); // TODO: get the 100 from the scene data

  return vec4<f32>(myColor.color.rgb * diffuse.rgb * att, myColor.color.a);
}


@vertex
fn vertexLineShader(
    @location(0) vertexPosition: vec3<f32>) -> ColorLineFragment {
  var output: ColorLineFragment;
  var vertex = myModel.model * vec4<f32>(vertexPosition, 1.0);

  let eye  = vec4<f32>(sceneData.invertView[3].xyz, 1.0);

  let eyeInViewSpace = sceneData.view * eye;
  let positionInViewSpace = sceneData.view * vertex;
  let bias = 0.002 * positionInViewSpace.z;
  let biasedPositionInViewSpace = positionInViewSpace - vec4<f32>(0.0, 0.0, bias, 0.0);
  output.viewZ = -biasedPositionInViewSpace.z;
  output.targetZ = eyeInViewSpace.z;
  output.position = sceneData.projection * biasedPositionInViewSpace;

  return output;
}


@fragment
fn fragmentLineShader(in: ColorLineFragment) -> @location(0) vec4<f32> {
  let att: f32 =  1.0 - clamp(in.viewZ / 100, 0.0, 1.0); // TODO: get the 100 from the scene data

  return vec4<f32>(myColor.color.rgb, myColor.color.a * att);
}
`,Ge="",Be=e=>{const{canvas:t,context:r,device:i}=e;let[o,s]=[t.width,t.height];return new ResizeObserver(n=>{const{width:a,height:c}=n[0].contentRect;[o,s]=[Math.round(a),Math.round(c)]}).observe(t.parentElement),n=>{if(o===t.width&&s===t.height){const h=r.getCurrentTexture(),f=n.colorAttachments;return f[0].view=h.createView({label:"ColorView"}),n}t.width=o,t.height=s;const a=i.createTexture({label:"DepthTexture",sampleCount:1,size:[o,s,1],format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT}),c=i.createTexture({label:"ColorTexture",size:{width:o,height:s,depthOrArrayLayers:1},sampleCount:1,format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT}),l=n.colorAttachments;l[0].view=c.createView({label:"ColorView"});const u=n.depthStencilAttachment;return u.view=a.createView({label:"DepthView"}),n}};class Mt{constructor(t,r,i,o){S(this,"canvas"),S(this,"context"),S(this,"device"),S(this,"format"),S(this,"_handleOnRender"),S(this,"_vertexCount",0),S(this,"_activeRenderLoop",!1),S(this,"_pipelineMode","default"),S(this,"_shaderModule"),S(this,"_pipelines",new Map),S(this,"_transformations",{projection:x.identity(),view:x.identity()}),S(this,"_renderPassDescription"),S(this,"_cameraTransHandler"),S(this,"_lightsHandler"),S(this,"_modelHandlers",{}),S(this,"_fps",St()),S(this,"_rebuildViewTexture"),S(this,"_ambientLight",[.3,.3,.3,1]),S(this,"_dirLights",[{dir:V.fromValues(0,0,1),col:[.4,.4,.4,1]},{dir:V.fromValues(1,1,1),col:[.4,.3,.3,0]},{dir:V.fromValues(1,0,0),col:[.5,.5,.5,0]},{dir:V.fromValues(-1,-1,-1),col:[.3,.3,.3,0]}]),S(this,"_pointLights",[{pos:b.fromValues(-12,12,8),col:[.5,.5,.2,0]},{pos:b.fromValues(12,12,8),col:[.4,.2,.2,0]},{pos:b.fromValues(-12,-12,8),col:[.2,.2,.5,0]},{pos:b.fromValues(12,-12,8),col:[.5,.1,.5,0]}]),S(this,"render",()=>{const{device:s}=this;this._vertexCount=0,this._handleOnRender&&this._handleOnRender(this);let n=this._renderPassDescription??Pt(this);this._rebuildViewTexture&&(this._renderPassDescription=this._rebuildViewTexture(n));const a=s.createCommandEncoder(),c=a.beginRenderPass(n),l=this._fps.getLastTimeSpan();this.updateLights(l),this.pipelines.filter(({geoRenderable:u})=>u.colors[0][3]===1).forEach((u,h)=>{this.renderPipeline(u,h,c,l)}),this.pipelines.filter(({geoRenderable:u})=>u.colors[0][3]<1).forEach((u,h)=>{this.renderPipeline(u,h,c,l)}),c.end(),s.queue.submit([a.finish()])}),this.canvas=t,this.context=r,this.device=i,this.format=o,this._rebuildViewTexture=Be(this),this.device.lost.then(()=>{console.log("WebGPU:device lost")})}get vertexCount(){return this._vertexCount}get fps(){return this._fps.getFPS()}get dirLights(){return this._dirLights}get pontLights(){return this._pointLights}setAmbientLight(t){this._ambientLight=t}setLight(t,r,i){switch(t){case"directional":this._dirLights[r]=i;break;case"point":this._pointLights[r]=i;break}}static async build(t){return ye(t).then(({canvas:r,context:i,device:o,format:s})=>new Mt(r,i,o,s))}setPipelineMode(t){this._pipelineMode=t}get pipelines(){return[...this._pipelines.values()]}getScene(){return[...this._pipelines.values()].map(({geoRenderable:t})=>t)}async setupShaders(t){if(this._shaderModule)return this;let r;if(be(t))switch(t){case"standard-3d":r=ze;break;case"standard-2d":default:r=Ge;break}else r=t.source;return this._shaderModule=await _e(this,r),this}setScene(t){if(!this._shaderModule)throw new Error("WebGPU:shader module is NOT available!");t.forEach(r=>{r.buildGpuBuffer(this)}),this._pipelines=Tt(this,this._shaderModule,t),this._renderPassDescription=Pt(this)}addToScene(t){if(!this._shaderModule)throw new Error("WebGPU:shader module is NOT available!");t.forEach(r=>{r.buildGpuBuffer(this)}),Tt(this,this._shaderModule,t).forEach((r,i)=>{this._pipelines.set(i,r)})}removeFromScene(t){return this._pipelines.delete(t)}clearScene(){this._pipelines.clear()}captureMouseMotion(t){Ie(this.canvas,{move:(t==null?void 0:t.move)??((r,i,o)=>{}),click:(t==null?void 0:t.click)??((r,i)=>{}),zoom:(t==null?void 0:t.zoom)??(r=>{}),tilt:(t==null?void 0:t.tilt)??(r=>{})})}sceneIntoBuffer(t){const{device:r}=this,{projection:i,view:o}=this._transformations,s=o.invert();let n=0;r.queue.writeBuffer(t[0],n,o.buffer()),n+=x.bufferSize,r.queue.writeBuffer(t[0],n,s.buffer()),n+=x.bufferSize,r.queue.writeBuffer(t[0],n,i.buffer()),n+=x.bufferSize;let a=0;const c=new Float32Array(this._dirLights.flatMap(({dir:h,col:f})=>[...h.coordinates,...f]));r.queue.writeBuffer(t[1],a,c),a+=c.byteLength;const l=new Float32Array(this._pointLights.flatMap(({pos:h,col:f})=>[...h.coordinates,...f]));r.queue.writeBuffer(t[1],a,l),a+=l.byteLength;const u=new Float32Array(this._ambientLight);r.queue.writeBuffer(t[1],a,u)}updateLights(t){if(!this._lightsHandler)return;const{dirLights:r,posLights:i}=this._lightsHandler;r&&r(t,this._dirLights),i&&i(t,this._pointLights)}onRender(t){this._handleOnRender=t}renderPipeline(t,r,i,o){const{pipeline:s,altPipeline:n,uniformBuffers:a,bindGroups:c,geoRenderable:l}=t,{device:u}=this;r===0&&(this.sceneIntoBuffer(a.sceneBuffers),i.setBindGroup(0,c.sceneGroup));const h=this._pipelineMode==="default"?s:n;i.setPipeline(h),this._modelHandlers[l.id]&&l.transform(o,this._modelHandlers[l.id]),u.queue.writeBuffer(a.modelBuffers[0],0,l.transformationData),i.setBindGroup(2,c.modelGroup),c.texturesGroup&&i.setBindGroup(3,c.texturesGroup),l.buffers.forEach((f,p)=>{const v=new Float32Array(l.colors[p]);u.queue.writeBuffer(a.colorBuffers[0],0,v),l.textureIndexes[p]&&u.queue.writeBuffer(a.colorBuffers[1],0,new Uint32Array([0])),i.setBindGroup(1,c.colorGroup);const m=l.getVertexCountPerStrip(p);this._vertexCount+=m,i.setVertexBuffer(0,f),i.draw(m)})}renderLoop(){const{width:t,height:r}=this.canvas;this._transformations=we(this._transformations,[t,r],this._cameraTransHandler),this.render(),this._fps.measureFPS(),this._activeRenderLoop&&requestAnimationFrame(this.renderLoop.bind(this))}beginRenderLoop(t){this._fps=St(),this._cameraTransHandler=t==null?void 0:t.camera,this._lightsHandler=t==null?void 0:t.lights,this._modelHandlers=(t==null?void 0:t.models)??{},this._activeRenderLoop=!0,this.renderLoop()}endRenderLoop(){this._activeRenderLoop=!1}}let it=new Map;const Ae=async e=>{var t,r;if(!navigator.gpu)return Promise.reject(new Error("WebGPU is not supported in this browser!"));const i=(t=it.get(e.id))==null?void 0:t.gpu;if(i)return Promise.resolve(i);if((r=it.get(e.id))!=null&&r.initializing)return new Promise((s,n)=>{setTimeout(()=>{var a;const c=(a=it.get(e.id))==null?void 0:a.gpu;if(c)return console.warn("WebGPU connection already initialized. Reusing previous connection."),s(c);n(new Error("WebGPU already initialization is taking too long!"))},100)});it.set(e.id,{initializing:!0});const o=await Mt.build(e);return it.set(e.id,{initializing:!1,gpu:o}),Promise.resolve(o)},Fe=(e,t,r)=>{const{device:i}=e,o="rgba8unorm",s={label:t,size:[r.width,r.height,1],format:o,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT},n=i.createTexture(s);i.queue.copyExternalImageToTexture({source:r},{texture:n},[r.width,r.height]);const a=n.createView({label:`${t}-view`});return{name:t,textures:[n],views:[a]}},De=e=>{let t=[];const r=/rgba?\(([^)]+)\)/.exec(e);if(r&&r[1]&&(t=r[1].split(",").map(a=>parseFloat(a.trim()))),t.length<3)throw new Error("Invalid RGB/RGBA format");const i=t[0]/255,o=t[1]/255,s=t[2]/255,n=t.length===4?t[3]:1;return{r:i,g:o,b:s,a:n}},Ee=async(e,t)=>{const r=new URL(t,window.location.href);return new Promise((i,o)=>{const s=new Image;s.src=r.href,s.onerror=n=>{o(n)},s.onload=()=>{createImageBitmap(s).then(n=>Fe(e,r.pathname,n)).then(n=>i([e,n]))}})},Re=async(e,t)=>Promise.all(t.map(r=>Ee(e,r))).then(r=>Promise.resolve([e,r.map(([,i])=>i)])),j=4;class ht{constructor(t,r,i=[[1,1,1,1]],o){S(this,"_body",null),S(this,"_id"),S(this,"_bufferData",null),S(this,"_vertices",[]),S(this,"_vertexColors",[]),S(this,"_vertexNormals",[]),S(this,"_vertexTextureCoords",[]),S(this,"_stripColors",[]),S(this,"_stripTextures",null),S(this,"_vertexByteSize",0),S(this,"_buffers",[]),S(this,"_bufferLayout",null),S(this,"_topology","triangle-list"),S(this,"_cullMode","back"),S(this,"_material",null),S(this,"_transformation",{rotation:R.identity(),scale:T.fromValues(1,1,1),translation:T.fromValues(0,0,0)}),this._id=t,this._topology=r,this._vertexByteSize=3*4,this._stripColors=i,this._stripTextures=o??null}get id(){return this._id}get label(){return this._topology}get translationVector(){return this._transformation.translation}get orientationRotation(){return this._transformation.rotation}get scaleVector(){return this._transformation.scale}get hasTextures(){return this._stripTextures!==null}get material(){return this._material}get vertexShader(){return this._topology==="triangle-strip"||this._topology==="triangle-list"?this.hasTextures?"vertexTextureShader":"vertexColorShader":"vertexLineShader"}get fragmentShader(){return this._topology==="triangle-strip"||this._topology==="triangle-list"?this.hasTextures?"fragmentTextureShader":"fragmentColorShader":"fragmentLineShader"}get colors(){return this._stripColors}get textureIndexes(){return this._stripTextures??[]}get primitives(){return this._topology}get cullMode(){return this._topology==="triangle-strip"||this._topology==="triangle-list"?this._cullMode:"none"}get vertexCount(){return this._vertices.reduce((t,r)=>t+r.length/3,0)}get body(){return this._body}get transformation(){return x.fromRotationTranslationScale(this._transformation.rotation,this._transformation.translation,this._transformation.scale)}get transformationData(){const t=this.transformation;return new Float32Array([...t.values,...t.transpose().invert().values])}setMaterial(t){this._material=t,this._stripTextures||(this._stripTextures=[0])}setBody(t){return this._body=t,this}scale(t){return this._transformation.scale=this._transformation.scale.multiply(t),this}translate(t){return this._transformation.translation=this._transformation.translation.add(t),this}rotate(t){return this._transformation.rotation=this._transformation.rotation.compose(t),this}rotoTranslate(t,r){const i=this._transformation;return i.rotation=t,i.translation=r,this}transform(t,r){return this._transformation=r(t,this._transformation),this}getVertexCountPerStrip(t){return this._vertices[t].length/3}get vertexByteSize(){return this._vertexByteSize}getByteSizePerStrip(t=0){return this._vertices[t].length*j+(this._vertexColors.length>0?this._vertexColors[t].length*j:0)+(this._vertexNormals.length>0?this._vertexNormals[t].length*j:0)+(this._vertexTextureCoords.length>0?this._vertexTextureCoords[t].length*j:0)}setCullMode(t){return this._cullMode=t,this}addVertices(t){this._vertices.push(t)}getBufferData(){return this._bufferData!==null?this._bufferData:(this._bufferData=this._vertices.map((t,r)=>{const i=[];for(let o=0,s=0,n=0,a=0;o<t.length;o+=3,s+=4,n+=3,a+=2){const c=[t[o+0],t[o+1],t[o+2]];this._vertexColors.length>r&&(c.push(this._vertexColors[r][s+0]),c.push(this._vertexColors[r][s+1]),c.push(this._vertexColors[r][s+2]),c.push(this._vertexColors[r][s+3])),this._vertexTextureCoords.length>r&&(c.push(this._vertexTextureCoords[r][a+0]),c.push(this._vertexTextureCoords[r][a+1])),this._vertexNormals.length>r&&(c.push(this._vertexNormals[r][n+0]),c.push(this._vertexNormals[r][n+1]),c.push(this._vertexNormals[r][n+2])),i.push(...c)}return new Float32Array(i)}),this._bufferData)}get layouts(){let t=0,r=0;const i=[{shaderLocation:t,offset:0,format:"float32x3"}];return t+=1,r+=3*j,this._vertexColors.length>0&&(i.push({shaderLocation:t,offset:r,format:"float32x4"}),t+=1,r+=4*j),this._vertexTextureCoords.length>0&&(i.push({shaderLocation:t,offset:r,format:"float32x2"}),t+=1,r+=2*j),this._vertexNormals.length>0&&(i.push({shaderLocation:t,offset:r,format:"float32x3"}),t+=1,r+=3*j),i}get buffers(){return this._buffers}get bufferLayout(){if(this._bufferLayout===null)throw new Error("TriangleData: Buffer layout is not available! - Did you call buildGpuBuffer() ?");return this._bufferLayout}buildGpuBuffer(t){this._buffers=this.getBufferData().map(r=>xe(t.device,r)),this._bufferLayout={arrayStride:this.vertexByteSize,attributes:this.layouts}}addColors(t){this._vertexColors.length===0&&(this._vertexByteSize+=4*4),this._vertexColors.push(t)}addNormals(t){var r;this._vertexNormals.length===0&&(this._vertexByteSize+=3*4),(r=this._vertexNormals)==null||r.push(t)}addTextures(t){this._vertexTextureCoords.length===0&&(this._vertexByteSize+=2*4),this._vertexTextureCoords.push(t)}}const tt=(e,t,r)=>{const{w:i,h:o}=t,s=i/2,n=o/2,a=e.origin,c=[],l=[],u=V.fromValues(0,0,1);c.push(b.fromValues(a.x-s,a.y-n,0)),c.push(b.fromValues(a.x+s,a.y-n,0)),c.push(b.fromValues(a.x-s,a.y+n,0)),c.push(b.fromValues(a.x-s,a.y+n,0)),c.push(b.fromValues(a.x+s,a.y-n,0)),c.push(b.fromValues(a.x+s,a.y+n,0)),l.push(u,u,u,u,u,u);const h=[],{pos:f,size:p}=r,{w:v,h:m}=p,d=v/2,y=m/2;h.push({u:f.u+d,v:f.v-y}),h.push({u:f.u-d,v:f.v-y}),h.push({u:f.u+d,v:f.v+y}),h.push({u:f.u+d,v:f.v+y}),h.push({u:f.u-d,v:f.v-y}),h.push({u:f.u-d,v:f.v+y});const P=c.map(_=>_.absolute(e)),M=l.map(_=>_.absolute(e));return[P,M,h]},et=(e,t)=>[e[0].map(r=>r.map(t).triplet).flat(),e[1].map(r=>r.map(t).triplet).flat(),e[2].map(r=>[r.u,r.v]).flat()],Ue=(e,t)=>{const{colors:r,id:i,textureIndexes:o}=t,s=x.rotationX(W(-90)),n=x.rotationX(W(180)),a=x.rotationX(W(90)),c=x.rotationZ(W(-90)).rotationY(W(90)),l=x.rotationZ(W(90)).rotationY(W(-90)),u=bt.from2Vectors(b.fromValues(0,0,.5),V.fromValues(0,0,1),V.fromValues(1,0,0)),h=u.map(n),f=u.map(s),p=u.map(a),v=u.map(c),m=u.map(l),d={w:.25,h:.25},y=tt(u,{w:1,h:1},{pos:{u:.25+.25/2,v:.25/2},size:d}),P=tt(h,{w:1,h:1},{pos:{u:.25+.25/2,v:.5+.25/2},size:d}),M=tt(f,{w:1,h:1},{pos:{u:.25+.25/2,v:.25+.25/2},size:d}),_=tt(p,{w:1,h:1},{pos:{u:.75+.25/2,v:.25+.25/2},size:d}),g=tt(v,{w:1,h:1},{pos:{u:0+.25/2,v:.25+.25/2},size:d}),w=tt(m,{w:1,h:1},{pos:{u:.5+.25/2,v:.25+.25/2},size:d}),[G,U,Z]=et(y,e),k=et(P,e),$=et(M,e),q=et(_,e),H=et(g,e),L=et(w,e);G.push(...k[0],...$[0],...q[0],...H[0],...L[0]),U.push(...k[1],...$[1],...q[1],...H[1],...L[1]),Z.push(...k[2],...$[2],...q[2],...H[2],...L[2]);const nt=new ht(i,"triangle-list",r,o);return nt.addVertices(new Float32Array(G)),nt.addNormals(new Float32Array(U)),o&&nt.addTextures(new Float32Array(Z)),nt},Ne=()=>Ue,Lt=(e,t,r)=>{const i=V.fromValues(0,0,1),o=V.fromValues(0,0,-1),s=[],n=[],a=r==="up"?0:Math.PI*2,c=r==="up"?Math.PI/e:-Math.PI/e,l=r==="up"?u=>u<Math.PI*2:u=>u>0;for(let u=a;l(u);u+=c){const h=b.fromValues(0,0,t),f=b.fromValues(.5*Math.cos(u),.5*Math.sin(u),t),p=b.fromValues(.5*Math.cos(u+c),.5*Math.sin(u+c),t);n.push(h),n.push(f),n.push(p),r==="up"?s.push(i,i,i):s.push(o,o,o)}return[n,s]},Oe=(e,t,r)=>{const i=[],o=[],s=Math.PI/e,n=b.fromValues(0,0,t),a=b.fromValues(0,0,r);for(let c=0;c<Math.PI*2;c+=s){const l=b.fromValues(.5*Math.cos(c),.5*Math.sin(c),t),u=V.fromVector(T.fromPoints(l,n));i.push(l),o.push(u);const h=b.fromValues(.5*Math.cos(c+s),.5*Math.sin(c+s),t),f=V.fromVector(T.fromPoints(h,n));i.push(h),o.push(f);const p=b.fromValues(.5*Math.cos(c),.5*Math.sin(c),r),v=V.fromVector(T.fromPoints(p,a));i.push(p),o.push(v);const m=b.fromValues(.5*Math.cos(c),.5*Math.sin(c),r),d=V.fromVector(T.fromPoints(m,a));i.push(m),o.push(d);const y=b.fromValues(.5*Math.cos(c+s),.5*Math.sin(c+s),t),P=V.fromVector(T.fromPoints(y,n));i.push(y),o.push(P);const M=b.fromValues(.5*Math.cos(c+s),.5*Math.sin(c+s),r),_=V.fromVector(T.fromPoints(M,a));i.push(M),o.push(_)}return[i,o]},ke=(e,t)=>{const{steps:r,colors:i,id:o,textureIndexes:s}=t,n=[],a=[],c=[],[l,u]=Lt(r,.5,"up"),[h,f]=Lt(r,-.5,"down"),[p,v]=Oe(r,-.5,.5);if(n.push(...l.map(d=>d.map(e))),n.push(...h.map(d=>d.map(e))),n.push(...p.map(d=>d.map(e))),s){let d=0,y=0;const P=l.map(g=>[g.x+.5,g.y+.5]),M=h.map(g=>[g.x+.5,g.y+.5]),_=p.map(g=>{const w=g.z+.5;let G=(Math.atan2(g.y,g.x)+Math.PI)/(2*Math.PI);return G<Math.min(d,y)&&(G+=1),y=d,d=G,[G,w]});c.push(...P),c.push(...M),c.push(..._)}a.push(...u),a.push(...f),a.push(...v);const m=new ht(o,"triangle-list",i,s);return m.addVertices(new Float32Array(n.map(d=>d.triplet).flat())),m.addNormals(new Float32Array(a.map(d=>d.triplet).flat())),s&&m.addTextures(new Float32Array(c.flat())),m},$e=()=>ke,A=.5257311121191336,F=.8506508083520399,qe=[V.fromValues(-A,0,F),V.fromValues(A,0,F),V.fromValues(-A,0,-F),V.fromValues(A,0,-F),V.fromValues(0,F,A),V.fromValues(0,F,-A),V.fromValues(0,-F,A),V.fromValues(0,-F,-A),V.fromValues(F,A,0),V.fromValues(-F,A,0),V.fromValues(F,-A,0),V.fromValues(-F,-A,0)],He=[[0,4,1],[0,9,4],[9,5,4],[4,5,8],[4,8,1],[8,10,1],[8,3,10],[5,3,8],[5,2,3],[2,7,3],[7,10,3],[7,6,10],[7,11,6],[11,0,6],[0,1,6],[6,1,10],[9,0,11],[9,11,2],[9,2,5],[7,2,11]];function Xe(e,t){return V.fromVector(e.add(t))}function Nt(e,t,r=1){const i=new Map,o=[];function s(n,a){const c=n<a,l=`${c?n:a}-${c?a:n}`,u=i.get(l);if(u)return u;const h=Xe(T.fromValues(...e[n].triplet),T.fromValues(...e[a].triplet));e.push(h);const f=e.length-1;return i.set(l,f),f}for(const[n,a,c]of t){const l=s(n,a),u=s(n,c),h=s(a,c);o.push([n,l,u]),o.push([a,h,l]),o.push([c,u,h]),o.push([l,h,u])}return r===1?[e,o]:Nt(e,o,r-1)}const pt=e=>{let t=Math.asin(e.z);return[(Math.atan2(e.y,e.x)+Math.PI)/(2*Math.PI),.5-t/Math.PI]},Ye=(e,t)=>{const{steps:r,colors:i,id:o,textureIndexes:s}=t,[n,a]=Nt(qe,He,r),c=[],l=[],u=[],h=b.fromValues(0,0,0);a.forEach(p=>{const v=b.fromVector(n[p[2]]),m=b.fromVector(n[p[1]]),d=b.fromVector(n[p[0]]),y=V.fromVector(T.fromPoints(v,h)),P=V.fromVector(T.fromPoints(m,h)),M=V.fromVector(T.fromPoints(d,h));if(c.push(...v.map(e).triplet),c.push(...m.map(e).triplet),c.push(...d.map(e).triplet),l.push(...y.triplet),l.push(...P.triplet),l.push(...M.triplet),s){const _=pt(y),g=pt(P),w=pt(M),G=Math.min(_[0],g[0],w[0]),U=Math.max(_[0],g[0],w[0]);Math.abs(U-G)>.8&&(_[0]<.4&&g[0]<.4?w[0]-=1:_[0]<.4&&w[0]<.4?g[0]-=1:g[0]<.4&&w[0]<.4?_[0]-=1:_[0]>.6&&g[0]>.6?w[0]+=1:_[0]>.6&&w[0]>.6?g[0]+=1:g[0]>.6&&w[0]>.6&&(_[0]+=1)),u.push(..._),u.push(...g),u.push(...w)}});const f=new ht(o,"triangle-list",i,s);return f.addVertices(new Float32Array(c)),f.addNormals(new Float32Array(l)),s&&f.addTextures(new Float32Array(u)),f},Ze=()=>Ye,je=(e,t)=>{const{colors:r,steps:i,id:o}=t,s=e.scaleVector,n=Math.max(s.x,s.y),a=Math.pow(i,Math.floor(Me(n,i)))/i,c=Math.floor(s.x/a),l=Math.floor(s.y/a),u=1/c,h=1/l,f=[];for(let v=0;v<c+1;v++){const m=b.fromValues(-.5+u*v,-.5,0).map(e),d=b.fromValues(-.5+u*v,.5,0).map(e);f.push(m,d)}for(let v=0;v<l+1;v++){const m=b.fromValues(-.5,-.5+h*v,0).map(e),d=b.fromValues(.5,-.5+h*v,0).map(e);f.push(m,d)}const p=new ht(o,"line-list",r);return p.addVertices(new Float32Array(f.flatMap(v=>v.triplet))),p},We=()=>je,Ke=(e,t=[10,10,10])=>{let r=b.fromValues(0,0,0),i=b.fromValues(...t),o=i.x===0&&i.y===0?V.fromValues(0,1,0):V.fromValues(0,0,1),s=[0,0],n=[0,0],a=0,c=0,l=Math.PI/5,u=T.fromPoints(i,r).lengthSquare,h=bt.lookAt(i,r,o),f=!1;return[{move:(p,v,m)=>{const d=Math.min(e.canvas.width,e.canvas.height);let y=1/Math.max(e.canvas.width,e.canvas.height)*Math.log(u)*Math.atan(l),P=l/d*2;switch(p){case"mouse-0":s=[v.direction[0]*y,v.direction[1]*y],f=!0;break;case"mouse-1":n=[-v.direction[0]*P,v.direction[1]*P];break;case"mouse-2":l+=v.direction[1]*P;break;case"none":f=!1;break}},zoom:p=>{const v=u*Math.atan(l)/3e3;a=p*v},tilt:p=>{c=p*5e-4,f=!1}},{view:p=>{if(!p||p!=null&&p.isIdentity)return x.lookAt(i,r,o);const v=T.fromPoints(i,r).scale(1-a);v.length>2&&v.length<200&&(i=r.add(v));const m=T.fromPoints(r,i),d=x.move(m).apply(h),y=[Math.tan(n[0])*u,Math.tan(n[1])*u],P=T.fromValues(y[0],y[1],0).absolute(d),M=d.relative(i);let _=d.relative(o);_=x.rotationZ(c).apply(_);const g=x.rotationX(-s[1]).compose(x.rotationY(-s[0]));i=g.apply(M).absolute(d),o=g.apply(_).absolute(d);const w=x.move(P);return r=w.apply(r),i=w.apply(i),h=bt.lookAt(i,r,o),f||(s=[s[0]*.95,s[1]*.95],c*=.9,a*=.9,Math.abs(s[0])<.001&&Math.abs(s[1])<.001&&Math.abs(c)<.001&&Math.abs(a)<.001&&(s=[0,0],c=0,a=0)),n=[0,0],u=T.fromPoints(i,r).length,h.toTransform()},projection:p=>{const v=e.canvas.width/e.canvas.height,m=T.fromPoints(i,r).length,d=Math.max(400,m*.8);return x.perspective(l,v,Math.max(.01,m-d),m+d)}}]},Qe=e=>{const t=-W(18),r=b.fromValues(10,0,0),i=b.fromValues(-5,0,3);e.setAmbientLight([.1,.1,.2,1]);const o=V.fromVector(b.origin().subtract(r));return e.setLight("directional",0,{dir:o,col:[.9,.9,.9,1]}),e.setLight("point",0,{pos:r,col:[.5,.5,.45,1]}),e.setLight("point",1,{pos:i,col:[.1,.1,.4,1]}),{dirLights:(s,n)=>{const a=s/1e3,c=x.rotationZ(t*a);n[0].dir=n[0].dir.map(c)},posLights:(s,n)=>{const a=s/1e3,c=x.rotationZ(t*a);n[0].pos=n[0].pos.map(c),n[1].pos=n[1].pos.map(c)}}},Je=e=>{const t=Ze()(x.scale(1.5,1.5,1.5),{id:"earth-sphere",steps:4,textureIndexes:[0]});return t.setMaterial(e),[t]},tr=e=>{const t=$e()(x.scale(2,2,2),{id:"cylinder",steps:24,textureIndexes:[0]});return t.setMaterial(e),[t]},er=e=>{const t=Ne()(x.scale(2,2,2),{id:"cube",textureIndexes:[0]});return t.setMaterial(e),[t]},Ot=()=>[We()(x.scale(50,50,1).translation(0,0,0),{id:"ref-plane",steps:50,colors:[[.3,.3,.5,.4]]})];async function rr(e,t){const r=await Ae(e);await r.setupShaders("standard-3d");const[i,o]=Ke(r,[6,6,4]);r.captureMouseMotion(i);const s=Qe(r);r.beginRenderLoop({camera:o,lights:s});const n=await Ot();return r.setScene(n),r}const ut=[],ir=(e,t)=>()=>{console.log("setWireframe",t.checked),t.checked?e.setPipelineMode("alternative"):e.setPipelineMode("default")},vt=(e,t)=>()=>{e.clearScene();const r=Ot();switch(t){case"globe":const i=Je(ut[0]);e.setScene([...i,...r]);break;case"cylinder":const o=tr(ut[1]);e.setScene([...o,...r]);break;case"cube":const s=er(ut[2]);e.setScene([...s,...r]);break}},mt=document.getElementById("support"),Ct=document.getElementById("gfx-canvas");!mt||!Ct?alert("The app is broken! No canvas was found!"):rr(Ct).then(e=>Re(e,["earth.jpg","metal.jpg","dice.png"])).then(([e,t])=>{ut.push(...t);const r=document.getElementById("wireframe");r.onclick=ir(e,r);const i=document.getElementById("geo-globe"),o=document.getElementById("geo-cylinder"),s=document.getElementById("geo-cube");i.onclick=vt(e,"globe"),o.onclick=vt(e,"cylinder"),s.onclick=vt(e,"cube"),i.click(),mt.innerText="All set!"}).catch(e=>{mt.innerText="Error: "+e.message});
